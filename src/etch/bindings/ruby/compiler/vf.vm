# This file automatically generated by:
#   $version
#   $now

# package '$intf/parent()/name()'

require 'etch/bindings/ruby/msg/field'
require 'etch/bindings/ruby/msg/type'
require 'etch/bindings/ruby/msg/struct_value'
require 'etch/bindings/ruby/support/default_value_factory'
require 'etch/bindings/ruby/msg/id_name'

#foreach( $n in $intf.iterator() )
#if ($n.isExtern())
#if ($n.hasImport( $helper ))
require '$n.getImport( $helper )'
#end
#if ($n.hasSerializerImport( $helper ))
require '$n.getSerializerImport( $helper )'
#end
#end
#end

#
# ValueFactory for $intf.name().
#
class ValueFactory$intf.name() < DefaultValueFactory
	
	
#foreach ( $n in $intf.iterator() )
#if ($n.isEnumx() || $n.isStruct() || $n.isExtern() || $n.isExcept() || $n.isMessage())
	# Type for $n.fqname() 
	$n.vname( $helper ) = Type.new( $n.id(), "$n.fqname()" )
	# { addType( $n.vname( $helper ) ) }

#end
#end
## ---------------------------------------------------------------------------
	def getType( id )
	
		case (id)
			when nil then raise "type's nil?"
#foreach( $n in $intf.iterator() )
#if ($n.isEnumx() || $n.isStruct() || $n.isExtern() || $n.isExcept() || $n.isMessage())
			when $n.id() then return $n.vname( $helper )
#end
#end
			else return super( id )
		end
	end

	def exportCustomValue( value )
	
		clss = value.class

#foreach ( $n in $intf.iterator() )
#if ($n.isStruct() || $n.isExcept())
#set( $tname = $n.efqname( $helper ) )
		if (clss == $intf.name()::$n.name())
		
			struct = StructValue.new( ValueFactory$intf.name()::$n.vname( $helper ) )
#foreach( $param in $n.iterator() )
			struct.store( ValueFactory$intf.name()::$param.vname( $helper ), value.$param.name() )
#end
			return struct
		end

#elseif ($n.isExtern())
#set( $tname = $n.efqname( $helper ) )
		if (clss == $intf.name()::$n.name())
		
			struct = StructValue.new( ValueFactory$intf.name()::$n.vname( $helper ) )
			# serialize $tname to struct using $n.sname( $helper )
			${n.sname( $helper )}.exportValue( this, ($tname) value, struct )
			return struct
		end

#elseif ($n.isEnumx())
#set( $tname = $n.efqname( $helper ) )

		if (clss == $intf.name()::$n.name())
		
			struct = StructValue.new( ValueFactory$intf.name()::$n.vname( $helper ) )
			case (value)
			
#foreach ($p in $n.iterator())
				when $intf.name()::$n.name()::$p.name() then struct.store( ValueFactory$intf.name()::$p.vname( $helper ), true )
#end
			end
			return struct
		end

#end
#end
		return super( value )
	end

	def importCustomValue( struct )
	
		type = struct.getType()
		case( type.xid )
			when nil then raise 'id nil?'
#foreach ( $n in $intf.iterator() )
#if ($n.isStruct() || $n.isExcept())
#set( $tname = $n.efqname( $helper ) )
			when $n.id() then begin
				return $intf.name()::${n.name()}.new(#set( $sep = "" )#foreach ($p in $n.iterator())#if ($p.type().dim() > 0)#					to_$p.type().type()(#						${helper.getTypeName( $p.type() )}.class,#end$sep struct[ ValueFactory$intf.name()::$p.vname( $helper ) ]#if ($p.type().dim() > 0)#					)#end#set( $sep = ", " )#end				)
			end

#elseif ($n.isExtern())
#set( $tname = $n.efqname( $helper ) )
			when $n.id() then begin
				// deserialize $tname from struct using $n.sname( $helper )
				return ${n.sname( $helper )}.importValue( this, struct )
			end

#elseif ($n.isEnumx())
#set( $tname = $n.efqname( $helper ) )
			when $n.id() then begin
				# assume there is a single key
				struct.each_key { |key| 
					case (key.xid)
	#foreach ($p in $n.iterator())
						when $p.id() then return $intf.name()::$n.name()::$p.name()
	#end
					end
				}
				return nil
			end

#end
#end
		end
		return super( struct )
	end

	def getCustomStructType( c )
	
#foreach ( $n in $intf.iterator() )
#if ($n.isEnumx() || $n.isStruct() || $n.isExtern() || $n.isExcept())
#set( $tname = $n.efqname( $helper ) )
		if ( c == $intf.name()::$n.name() ) 
			return ValueFactory$intf.name()::$n.vname( $helper )
		end
#end
#end
		return nil
	end

	def getCustomType( type )
	
		case (type.xid)
			when nil then raise 'id nil?'
#			when -1201742561 then return Time
#foreach ( $n in $intf.iterator() )
#if ($n.isEnumx() || $n.isStruct() || $n.isExtern() || $n.isExcept())
#set( $tname = $n.efqname( $helper ) )
			when $n.id() then return $intf.name()::$n.name()
#end
#end
		end
		
		return nil
	end

#set( $x = $params.clear() )
#foreach( $n in $intf.iterator() )
#if ($n.isEnumx() || $n.isStruct() || $n.isExcept() || $n.isMessage())
#foreach( $param in $n.iterator() )
#if (!$params.contains($param.name().name()))
#set( $x = $params.add($param.name().name()) )
	# Field for $param.name().name() 
	$param.vname( $helper ) = Field.new( $param.id(), "$param.name().name()" )
	#{ addField( $param.vname( $helper ) ); }
	
#end
#end
#end
#end
##
	def getField( id )
	
		case (id)
			when nil then raise 'id nil?'	
#set( $x = $params.clear() )
#foreach( $n in $intf.iterator() )
#if ($n.isEnumx() || $n.isStruct() || $n.isExcept() || $n.isMessage())
#foreach( $param in $n.iterator() )
#if (!$params.contains($param.name().name()))
#set( $x = $params.add($param.name().name()) )
			when $param.id() then return $param.vname( $helper )
#end
#end
#end
#end
			else return super( id )
		end
	end
#foreach( $n in $intf.iterator() )
#if ($n.isEnumx() || $n.isStruct() || $n.isExtern() || $n.isExcept())
#set( $tname = $n.efqname( $helper ) )

#end
#end
end
