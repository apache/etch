# This file automatically generated by:
#   $version
#   $now
#set($i = $intf.name())
#set($vfname = "ValueFactory$i")
#set($intfname = "$i$suffix")
#set($clname = "Remote$intfname")

require 'etch/bindings/ruby/msg/message'
require 'etch/bindings/ruby/support/delivery_service'
require 'etch/bindings/ruby/support/mailbox'
require 'etch/bindings/ruby/idl/test/Test'

#if (!$hasBaseClass)
require 'etch/bindings/ruby/support/remote_base'
#end
#if ($hasBaseClass)
require 'etch/bindings/ruby/idl/test/RemoteTest'
require 'etch/bindings/ruby/idl/test/$intfname'
#end
#foreach( $n in $intf.iterator() )
#if ($n.isExtern())
#if ($n.hasImport( $helper ))
require '$n.getImport( $helper )'
#end
#end
#end

#
# Call to message translator for $intfname.
#
#if ($hasBaseClass)
class $clname < Remote$i 
	include $intfname
#else
class $clname < RemoteBase 
	include $intfname
#end

	#
	# Constructs the $clname.
	#
	# @param svc
	#
	# first param should be delivery service
	# second param should be the value factory (optional)
	def initialize( *args )
		
		if ( args[1] == nil)
			super( args[0], ${vfname}.new )
		else
			super( args[0], args[1] )
		end	
	end

#foreach ($mthd in $intf.iterator())
#if ($mthd.isMsgDir($mc))
#if (!$mthd.isHidden())
#if ($mthd.isOneway())
	def $mthd.name()(#set( $sep = "" )#foreach( $param in $mthd.iterator() )$sep$param.name()#set( $sep = ", " )#end )
	
		_msg = _newMessage( $vfname::$mthd.vname( $helper ) )
#foreach( $param in $mthd.iterator() )
		_msg.store( $vfname.$param.vname( $helper ), $param.name() )
#end
		begin
		
			_svc.send( _msg )
		
		rescue Exception => _e 
		
			raise Exception, "unexpected", _e 
		end
	end
#else
	def $mthd.name()(#set( $sep = "" )#foreach( $param in $mthd.iterator() )$sep$param.name() #set( $sep = ", " )#end)
#if ($mthd.thrown().iterator().hasNext())
	#throws
#set( $sep = "" )
#foreach($t in $mthd.thrown().iterator())
	#	$sep$t.name().name()
#set( $sep = ", " )
#end
#end
	
#if ($mthd.hasReturn())
		return #end _end_${mthd.name()}( _begin_${mthd.name()}(#set( $sep = "" )#foreach( $param in $mthd.iterator() )$sep$param.name() #set( $sep = ", " )#end	) )
	end
	
	def _begin_${mthd.name()}(#set( $sep = "" ) #foreach( $param in $mthd.iterator() ) $sep$param.name() #set( $sep = ", " ) #end	)
	
		_msg = _newMessage( $vfname::$mthd.vname( $helper ) )
#foreach( $param in $mthd.iterator() )
		_msg.store( $vfname::$param.vname( $helper ), $param.name() )
#end
		return _svc.begincall( _msg )
	end
	
	def _end_${mthd.name()}( _mb )
#if ($mthd.thrown().iterator().hasNext())
		# throws
#set( $sep = "" )
#foreach($t in $mthd.thrown().iterator())
		#	$sep$t.name().name()
#set( $sep = ", " )
#end
#end
	
		begin
		
#if ($mthd.hasReturn())
			return	#if ($mthd.type().dim() > 0)#end _svc.endcall( _mb, $vfname::$mthd.getResultMessage().vname( $helper ), $vfname::MF_result, $mthd.getTimeout() ) #if ($mthd.type().dim() > 0) #end	#else _svc.endvoidcall( _mb,$vfname::$mthd.getResultMessage().vname( $helper ),$vfname::MF_result, $mthd.getTimeout() ) #end		
		
		rescue Exception =>_e 
		
#foreach($t in $mthd.thrown().iterator())
			if (_e.class == $t.name()) 
				raise _e 
			end
#end
			raise _e, "unexpected"
		end
	end

#end
#end
#end
#end
end
