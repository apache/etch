# This file automatically generated by:
#   $version
#   $now
#set($i = $intf.name())

# package $intf/parent()/name();

require 'etch/bindings/ruby/msg/message'
require 'etch/bindings/ruby/support/message_source'
require 'etch/bindings/ruby/support/pool'
require 'etch/bindings/ruby/support/etch__auth_exception'
require 'etch/bindings/ruby/support/who'
require 'etch/bindings/ruby/support/default_value_factory'
require 'etch/bindings/ruby/idl/test/ValueFactoryTest'
#if ($hasBaseClass)
require 'etch/bindings/ruby/idl/test/Stub$i'
#end

#if (!$hasBaseClass)
require 'etch/bindings/ruby/support/stub_base'
#end
# import etch.bindings.java.support.Pool.PoolRunnable;
#foreach( $n in $intf.iterator() )
#if ($n.isExtern())
#if ($n.hasImport( $helper ))
require $n.getImport( $helper )
#end
#end
#end

# 
# Message to call translator for $i$suffix.
# 
#if ($hasBaseClass)
class Stub$i$suffix < Stub$i
#else
class Stub$i$suffix < StubBase
#end

	#
	# Stub for $i$suffix.
	# @param obj the implementation of $i$suffix responsive to requests.
	# @param queued thread pool used to run AsyncReceiverMode.QUEUED methods.
	# @param free thread pool used to run AsyncReceiverMode.FREE methods.
	#
	def initialize( obj, queued, free )
	
		super( obj, queued, free )
		@_obj = obj
		@vf = ValueFactory${i}.new
	end
	
	def message( _src, _sender, _msg )
	
		if (_msg == nil)
		
			super.message( _src, _sender, _msg )
			return true
		end

		case (_msg.getType().xid)
			when nil then raise "nil id"
#foreach( $mthd in $intf.iterator() )
#if ($mthd.isMsgDir($mc))
#if (!$mthd.isHidden())
			when $mthd.id() then begin
#if ($mthd.isAsyncReceiver())
				_${helper.asyncReceiverPoolName( $mthd )}.run( new PoolRunnable() { public void run() throws Exception {
#end
				do_$mthd.name()( _src, _sender, _msg )
#if ($mthd.isAsyncReceiver())
				} } )
#end
				return true
			end
#end
#end
#end
			
			else return super.message( _src, _sender, _msg )
		end
	end
#foreach( $mthd in $intf.iterator() )
#if ($mthd.isMsgDir($mc))
#if (!$mthd.isHidden())

	#
	# @param _src
	# @param _sender
	# @param _msg
	#
	def do_$mthd.name()( _src, _sender, _msg )
	
		begin
		
#foreach ($param in $mthd.iterator())
			$param.name() =
#if ($param.type().dim() > 0)
#end
					_msg[ ValueFactory$i::$param.vname( $helper ) ]
#if ($param.type().dim() > 0)
#end
#end

#if ($mthd.hasAuth())
#set( $auth = $mthd.getAuth() )
			if (!@_obj.${auth.method()}(
#set( $sep = "" )
#foreach($arg in $auth.args())
#if ($arg.isLiteralConstant())
				($helper.getNativeTypeName( $arg.type() )) $sep$helper.getTypeValue( $arg.type(), $arg.value() )
#elseif ($arg.isParameter( $mthd ))
				$sep$helper.qualifyParameterName( $arg.value() )
#elseif ($arg.isConstant( $intf ))
				$sep$helper.qualifyConstantName( $intf, $arg.value() )
#elseif ($arg.isEnum( $intf ))
				$sep$helper.qualifyEnumName( $intf, $arg.value() )
#else
				${sep}null
#end
#set( $sep = ", " )
#end
			)) raise _Etch_AuthException, "$mthd.name()" 
#end
#if ($mthd.hasReturn())
			_result =
#end
			@_obj.$mthd.name()(#set( $sep = "" )#foreach ($param in $mthd.iterator())$sep$param.name() #set( $sep = ", " )#end	)
#if (!$mthd.isOneway())
#set($rmthd = $mthd.getResultMessage())

			_rmsg = _msg.reply( ValueFactory$i::$rmthd.vname( $helper ) )
#if ($mthd.hasReturn())
			_rmsg.store( ValueFactory${i}::MF_result, _result )
#end
			_src.message( _sender, _rmsg )
#end
		
		rescue Exception => e 
		
#if (!$mthd.isOneway())
#set($rmthd = $mthd.getResultMessage())
			_rmsg = _msg.reply( ValueFactory$i::$rmthd.vname( $helper ) )
#else
			_rmsg = _msg.reply( ValueFactory{$i}::MT__exception )
#end
			_rmsg.store( ValueFactory${i}::MF_result, e )
			_src.message( _sender, _rmsg )
		end
	end
#end
#end
#end
end