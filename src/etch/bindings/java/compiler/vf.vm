// This file automatically generated by:
//   $version
//   $now

package $intf.parent().name();

import java.util.Set;

import etch.bindings.java.msg.Field;
import etch.bindings.java.msg.ImportExportHelper;
import etch.bindings.java.msg.StructValue;
import etch.bindings.java.msg.Type;
import etch.bindings.java.msg.ValueFactory;

import etch.bindings.java.support.AsyncMode;
import etch.bindings.java.support.Class2TypeMap;
import etch.bindings.java.support.DefaultValueFactory;
import etch.bindings.java.support.FieldMap;
import etch.bindings.java.support.TypeMap;

#foreach( $n in $intf.iterator() )
#if ($n.isExtern())
#if ($n.hasImport( $helper ))
import $n.getImport( $helper );
#end
#if ($n.hasSerializerImport( $helper ))
import $n.getSerializerImport( $helper );
#end
#end
#end

/**
 * ValueFactory for $intf.name().
 */
@SuppressWarnings("unused")
public final class ValueFactory$intf.name() extends DefaultValueFactory
{
	/**
	 * Constructs ValueFactoryTest1.
	 */
	public ValueFactory${intf.name()}()
	{
		super( types, class2type );
#foreach ( $n in $intf.iterator() )
#if ($n.isMixin())
#set( $m = $n.getModule() )
#set( $s = $m.iterator().next() )
		addMixin( new ${m.name()}.ValueFactory${s.name()}() );
#end
#end
	}
	
	private final static TypeMap types = new TypeMap();
	
	private final static Class2TypeMap class2type = new Class2TypeMap();

	static
	{
		DefaultValueFactory.init( types, class2type );
		initTypes();
		initResults();
		initFields();
		initParams();
	}
#foreach ( $n in $intf.iterator() )
#if ($n.isEnumx() || $n.isStruct() || $n.isExtern() || $n.isExcept() || $n.isMessage())

	/** Type for $n.fqname() */
	public static Type ${n.vname( $helper )};
#end
#end

	private static void initTypes()
	{
#foreach ( $n in $intf.iterator() )
#if ($n.isEnumx() || $n.isStruct() || $n.isExtern() || $n.isExcept() || $n.isMessage())
		${n.vname( $helper )} = types.get( "$n.fqname()" );
#end
#end
	}

	private static void initResults()
	{
#foreach ( $n in $intf.iterator() )
#if ($n.isMessage())
#if (!$n.isHidden())
#if ($n.isQueuedAsyncReceiver())
		${n.vname( $helper )}.setAsyncMode( AsyncMode.QUEUED );
#elseif ($n.isFreeAsyncReceiver())
		${n.vname( $helper )}.setAsyncMode( AsyncMode.FREE );
#end
#if (!$n.isOneway())
#set( $r = $n.getResultMessage() )
		${n.vname( $helper )}.setResult( $r.vname( $helper ) );
		${r.vname( $helper )}.setTimeout( $n.getTimeout() );
#end
#end
#end
#end
	}
## ----------------------------- import / export -----------------------------
#foreach ( $n in $intf.iterator() )
#if ($n.isStruct() || $n.isExcept())
#set( $tname = $n.efqname( $helper ) )

	static
	{
		class2type.put( ${tname}.class, ${n.vname( $helper )} );
		${n.vname( $helper )}.setComponentType( ${tname}.class );
#if ($n.hasExtends())
		${n.vname( $helper )}.setSuperType( $n.getExtends().vname( $helper ) );
#end
		${n.vname( $helper )}.setImportExportHelper( new ImportExportHelper()
		{
			public final StructValue exportValue( Object value )
			{
				StructValue struct = new StructValue( ${n.vname( $helper )} );
				$tname v = ($tname) value;
#foreach( $p in $n.getAllParameters() )
				struct.put( $p.vname( $helper ), v.$p.name() );
#end
				return struct;
			}

			public final Object importValue( StructValue struct )
			{
				$tname v = new ${tname}();
#foreach ($p in $n.getAllParameters())
				v.$p.name() = ($helper.getTypeName( $p.type() )) struct.get( $p.vname( $helper ) );
#end
				return v;
			}
		} );
	}
#elseif ($n.isExtern())
#set( $tname = $n.efqname( $helper ) )
#elseif ($n.isEnumx())
#set( $tname = $n.efqname( $helper ) )

	static
	{
		class2type.put( ${tname}.class, ${n.vname( $helper )} );
		${n.vname( $helper )}.setComponentType( ${tname}.class );
		${n.vname( $helper )}.setImportExportHelper( new ImportExportHelper()
		{
			public final StructValue exportValue( Object value )
			{
				StructValue struct = new StructValue( ${n.vname( $helper )} );
				${tname} v = (${tname}) value;
				switch (v)
				{
#foreach ($p in $n.iterator())
					case $p.name(): struct.put( $p.vname( $helper ), true ); break;
#end
				}
				return struct;
			}

			public final Object importValue( StructValue struct )
			{
				// there should only be a single key, so take the first one
				Field key = struct.keySet().iterator().next();
#foreach ($p in $n.iterator())
				if (key == $p.vname( $helper )) return ${tname}.$p.name();
#end
				return null;
			}
		} );
	}
#end
#end
## ----------------------------- fields -----------------------------
#set( $x = $params.clear() )
## standard params from DefaultValueFactory
#set( $x = $params.add( "msg" ) )
#set( $x = $params.add( "result" ) )
#foreach( $n in $intf.iterator() )
#if ($n.isEnumx() || $n.isStruct() || $n.isExcept() || $n.isMessage())
#foreach( $param in $n.iterator() )
#if (!$params.contains($param.name().name()))
#set( $x = $params.add($param.name().name()) )

	/** Field for $param.name().name() */
	public static Field $param.vname( $helper );
#end
#end
#end
#end

	private static void initFields()
	{
#set( $x = $params.clear() )
## standard params from DefaultValueFactory
#set( $x = $params.add( "msg" ) )
#set( $x = $params.add( "result" ) )
#foreach( $n in $intf.iterator() )
#if ($n.isEnumx() || $n.isStruct() || $n.isExcept() || $n.isMessage())
#foreach( $param in $n.iterator() )
#if (!$params.contains($param.name().name()))
#set( $x = $params.add($param.name().name()) )
		$param.vname( $helper ) = new Field( "$param.name().name()" );
#end
#end
#end
#end

#foreach ( $n in $intf.iterator() )
#if ($n.isMessage())
#if (!$n.isHidden())
#if (!$n.isOneway())
#set( $r = $n.getResultMessage() )
		${r.vname( $helper )}.setResponseField( _mf_result );
#end
#end
#end
#end
	}
	
	static
	{
		// initialize the extern serializers:
#foreach( $n in $intf.iterator() )
#if ($n.isExtern())
		${n.sname( $helper )}.init( ${n.vname( $helper )}, class2type );
#end
#end
	}

#set( $ctr = 0 )
	private static void initParams()
	{
#foreach( $n in $intf.iterator() )
#if ($n.isEnumx() || $n.isStruct() || $n.isExcept() || $n.isMessage())
#if ($ctr > 0 && $ctr % 100 == 0)

		initParams${ctr}();
	}
	
	private static void initParams${ctr}()
	{
#end
#set( $ctr = $ctr + 1 )

		// params for $n.name()
#if ($n.isStruct() || $n.isExcept())
#foreach( $param in $n.getAllParameters() )
		${n.vname( $helper )}.putValidator( $param.vname( $helper ), etch.bindings.java.support.$helper.getValidator( $param ) );
#end
#else
#foreach( $param in $n.iterator() )
		${n.vname( $helper )}.putValidator( $param.vname( $helper ), etch.bindings.java.support.$helper.getValidator( $param ) );
#end
#end
#if ($n.isMessage())
		${n.vname( $helper )}.putValidator( _mf__messageId, etch.bindings.java.support.Validator_long.get( 0 ) );
#if ($n.isHidden())
#set( $param = $n.getResultParam() )
#set( $reqMsg = $n.getRequestMessage() )
#foreach( $t in $reqMsg.thrown().iterator() )
		${n.vname( $helper )}.putValidator( $param.vname( $helper ), etch.bindings.java.support.$helper.getValidator( $t ) ); // thrown $t.name()
#end
		${n.vname( $helper )}.putValidator( $param.vname( $helper ), etch.bindings.java.support.Validator_RuntimeException.get() ); // thrown RuntimeException
		${n.vname( $helper )}.putValidator( _mf__inReplyTo, etch.bindings.java.support.Validator_long.get( 0 ) );
#end
#end
#end
#end
	}
	
	static
	{
		// done updating types, and class2type: lock them.
		types.lock();
		for (Type t: types.values())
			t.lock();
		class2type.lock();
	}
}
