// This file automatically generated by:
//   $version
//   $now
#set($i = $intf.name())

package $intf.parent().name();
import java.util.HashMap;
import java.util.Map;

import metreos.util.URL;
import etch.bindings.java.msg.ValueFactory;
import etch.bindings.java.support.Pool;
import etch.bindings.java.transport.DefaultDeliveryService;
import etch.bindings.java.transport.Messagizer;
import etch.bindings.java.transport.Resources;
import etch.bindings.java.transport.ServerFactory;
import etch.bindings.java.transport.Transport;
import etch.bindings.java.transport.TransportFactory;
import etch.bindings.java.transport.TransportHelper;
#foreach( $n in $intf.iterator() )
#if ($n.isExtern())
#if ($n.hasImport( $helper ))
import $n.getImport( $helper );
#end
#if ($n.hasSerializerImport( $helper ))
import $n.getSerializerImport( $helper );
#end
#end
#end

/**
 * Transport helper for ${intf.name()}.
 */
public class ${intf.name()}Helper extends TransportHelper
{
	private ${intf.name()}Helper() { /* nothing */ }

	/**
	 * Constructs a new server session listener per specifications
	 * in uri and resources.
	 *
	 * @param uri contains specifications for the server session
	 * listener and for the server session transport stack.
	 *
	 * @param resources additional resources to aid in constructing
	 * new server sessions.
	 *
	 * @param implFactory called upon accepting a new server session to
	 * construct a new server implementation to handle messages
	 * from the client during the session.
	 *
	 * @return an out-of-band source that may be used to control
	 * the listener.
	 *
	 * @throws Exception
	 */
	public static Transport new${intf.name()}Listener( URL uri,
		Resources resources, final ${intf.name()}ServerFactory implFactory )
		throws Exception
	{
		final Resources res = initResources( resources );

		final TransportFactory factory = TransportFactory.get( uri.getScheme() );

		return factory.newListener( uri, res, new ServerFactory()
		{
			public void newServer( DefaultDeliveryService d ) throws Exception
			{
				${intf.name()}Client client = new Remote${intf.name()}Client( d );
				${intf.name()}Server server = implFactory.new${intf.name()}Server( client );
				Pool qp = (Pool) res.get( QUEUED_POOL );
				Pool fp = (Pool) res.get( FREE_POOL );
				d.addStub( new Stub${intf.name()}Server( d.getSource(), server, qp, fp ) );
			}

			public ValueFactory newValueFactory()
			{
				return new ValueFactory${intf.name()}();
			}
		} );
	}

	/**
	 * Constructs a new client session per specifications in uri
	 * and resources.
	 *
	 * @param uri contains specifications for the client session
	 * transport stack.
	 *
	 * @param resources additional resources to aid in constructing
	 * new sessions.
	 *
	 * @param client an client implementation to handle any
	 * messages from the server during the session.
	 *
	 * @return new remote server instance initialized by uri
	 * and resources which may be used to send messages to the
	 * server session.
	 *
	 * @throws Exception
	 */
	public static Remote${intf.name()}Server new${intf.name()}Server( URL uri,
		Resources resources, ${intf.name()}Client client )
		throws Exception
	{
		resources = initResources( resources );
		resources = new Resources( resources );
		resources.put( Messagizer.VALUE_FACTORY, new ValueFactory${intf.name()}() );

		TransportFactory factory = TransportFactory.get( uri.getScheme() );

		DefaultDeliveryService d = factory.newTransport( uri, resources );

		if (client != null)
			d.addStub( new Stub${intf.name()}Client( null,
				client,
				(Pool) resources.get( QUEUED_POOL ),
				(Pool) resources.get( FREE_POOL ) ) );

		return new Remote${intf.name()}Server( d );
	}

	/**
	 * Factory for a Listener to use to create new instances of ${intf.name()}Server.
	 */
	public interface ${intf.name()}ServerFactory
	{
		/**
		 * @param client an ${intf.name()}Client instance for server implementation
		 * to use to call back to the client.
		 * @return an instance of ${intf.name()}Server (e.g., Impl${intf.name()}Server) to
		 * handle messages which arrive from the client.
		 * @throws Exception
		 */
		public ${intf.name()}Server new${intf.name()}Server( ${intf.name()}Client client )
			throws Exception;
	}

}
