// This file automatically generated by:
//   $version
//   $now
#set($i = $intf.name())

using System;
using System.Collections.Generic;
using System.Text;

using Etch.Msg;
using Etch.Support;
using Etch.Transport;
using System.Collections;
using Etch.Util;

/// <summary>
/// Transport helper for ${intf.name()}.
/// </summary>
namespace $intf.parent().name()
{
    public class ${intf.name()}Helper : TransportHelper
    {

        private ${i}Helper()
        {
            // nothing
        }

		///
		/// <summary>Constructs a new server session listener per specifications
		/// in uri and resources.</summary>
		///
		/// <param name="uri"> contains specifications for the server session
		/// listener and for the server session transport stack.</param>
		///
		/// <param name="resources"> additional resources to aid in constructing
		/// new server sessions.</param>
		///
		/// <param name="implFactory"> called upon accepting a new server session to
		/// construct a new server implementation to handle messages
		/// from the client during the session.</param>
		///
		/// <returns> an out-of-band source that may be used to control
		/// the listener.</returns>
		///

		public static Transport New${intf.name()}Listener( URL uri,		
			Resources resources, ${intf.name()}ServerFactory implFactory )
		{
			Resources res = InitResources( resources );

			TransportFactory factory = TransportFactory.Get( uri.Scheme );
			
			return factory.NewListener( uri, res, new MyServerFactory( uri, res, implFactory ) );
		}
		
		///
		/// <summary>Constructs a new client session per specifications in uri
		/// and resources.</summary>
		///
		/// <param name="uri"> contains specifications for the client session
		/// transport stack.</param>
		///
		/// <param name="resources"> additional resources to aid in constructing
		/// new sessions.</param>
		///
		/// <param name="client"> an client implementation to handle any
		/// messages from the server during the session.</param>
		///
		/// <returns> new remote server instance initialized by uri
		/// and resources which may be used to send messages to the
		/// server session.</returns>
		///
		
		public static Remote${intf.name()}Server New${intf.name()}Server( URL uri,
			Resources resources, ${intf.name()}Client client )
		{
			resources = InitResources( resources );
			resources = new Resources( resources );
			resources.Add( Messagizer.VALUE_FACTORY, new ValueFactory${intf.name()}() );
	
			TransportFactory factory = TransportFactory.Get( uri.Scheme );
	
			DefaultDeliveryService d = factory.NewTransport( uri, resources );
	
			if (client != null)
				d.AddStub( new Stub${intf.name()}Client( null,
					client,
					(Pool) resources[ QUEUED_POOL ],
					(Pool) resources[ FREE_POOL ] ) );
	
			return new Remote${intf.name()}Server( d );
		}
		
		/// <summary>
		/// Factory for a Listener to use to create new instances of ${intf.name()}Server.
		/// </summary>
		///
		public interface ${intf.name()}ServerFactory
		{
			///
			/// <param name="client"> an ${intf.name()}Client instance for server implementation
			/// to use to call back to the client.</param>
			/// <returns> an instance of ${intf.name()}Server (e.g., Impl${intf.name()}Server) to
			/// handle messages which arrive from the client.</returns>
			///
			${intf.name()}Server New${intf.name()}Server( ${intf.name()}Client client );
		}
		
		public class MyServerFactory : ServerFactory
		{
		
			private URL _uri;
			private Resources _resources;
			private ${intf.name()}ServerFactory _implFactory;
			
			public MyServerFactory( URL uri, Resources resources, ${intf.name()}ServerFactory implFactory ) 
			{
				_uri = uri;
				_resources = resources;
				_implFactory = implFactory;
			}
		
			public void NewServer( DefaultDeliveryService d )
			{
				${intf.name()}Client client = new Remote${intf.name()}Client( d );
				${intf.name()}Server server = _implFactory.New${intf.name()}Server( client );
				Pool qp = (Pool) _resources[ QUEUED_POOL ];
				Pool fp = (Pool) _resources[ FREE_POOL ];
				d.AddStub( new Stub${intf.name()}Server( d.GetSource(), server, qp, fp ) );
			}
			
			public ValueFactory NewValueFactory()
			{
				return new ValueFactory${intf.name()}();
			}
		}

	}
}
