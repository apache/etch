// This file automatically generated by:
//   $version
//   $now

namespace $intf.parent().name()
{
using System;

#foreach( $n in $intf.iterator() )
#if ($n.isExtern())
#if ($n.hasImport( $helper ))
using $n.getImport( $helper );
#end
#end
#end
///
#foreach( $s in $intf.descr() )
/// $s
#end
///
#if ($hasBaseClass)
public interface $intf.name()$suffix : $intf.name()
#else
public interface $intf.name()$suffix
#end
{
#if (!$intf.hasMessageDirection($mc))
	// no $mc direction items defined.
#end
#foreach( $n in $intf.iterator() )
#if ($n.isMessage())
#if ($n.isMsgDir($mc))
#if (!$n.isHidden())
	///
#foreach( $s in $n.descr() )
	/// $s
#end
#foreach( $p in $n.iterator() )
#set($first = true)
#foreach( $s in $p.descr() )
#if ($first)
#set($first = false)
	/// <param name="$p.name()">$s</param>
#else
	/// $s
#end
#end
#end
#if ($n.hasReturn())
#set($first = true)
#foreach( $s in $n.returnDescr() )
#if ($first)
#set($first = false)
	/// <returns> $s </returns>
#else
	/// $s
#end
#end
#end
#foreach($t in $n.thrown().iterator())
#set($first = true)
#foreach( $s in $t.descr() )
#if ($first)
#set($first = false)
	/// Exception:
	///	 throws $t.name() $s
#else
	/// $s
#end
#end
#end
	///
	$helper.getTypeName( $n.type() ) $n.name()(
#set( $sep = "" )
#foreach( $p in $n.iterator() )
		$sep$helper.getTypeName( $p.type() ) $p.name()
#set( $sep = ", " )
#end
	)
#if ($n.hasThrown())
/// throws
#set( $sep = "" )
#foreach($t in $n.thrown().iterator())
/// $sep$t.name().name()
#set( $sep = ", " )
#end
#end
;
#end
#end
#elseif ($n.isConstant())
#elseif ($n.isEnumx())
#elseif ($n.isStruct() || $n.isExcept())
#elseif ($n.isExtern())
## ignore extern
#else
*** don't know what to do with $n ***
#end
#end
}

public abstract class Consts$intf.name()$suffix
{
#foreach( $n in $intf.iterator() )
#if ($n.isConstant())
#if (!$hasBaseClass)
	///
#foreach( $s in $n.descr() )
	/// $s
#end
	public static $helper.getNativeTypeName( $n.type() ) $n.name() = $helper.getTypeValue( $n.type(), $n.value() );

#end
#elseif ($n.isEnumx())
#if (!$hasBaseClass)
	/// 
#foreach( $s in $n.descr() )
	/// $s
#end
	public enum $n.name()
	{
#set( $sep = "" )
#foreach( $i in $n.iterator() )
		///
#foreach( $s in $i.descr() )
		/// $s
#end
		///
		$sep$i.name()
#set( $sep = ", " )
#end
	}
#end
#elseif ($n.isStruct() || $n.isExcept())
#if (!$hasBaseClass)
	///
#foreach( $s in $n.descr() )
	/// $s
#end
	///
	public class $n.name()
#if( $n.isExcept() )
#if( $n.isUnchecked() )
		: Exception
#else
		: Exception
#end
#end
	{
		///
		/// <summary>Constructs the $n.name(). Don't init anything.</summary>
		///
		public $n.name()()
		{
			// don't init anything.
		}

#if ($n.hasParameters())
		///
		/// Constructs the $n.name().
#foreach( $i in $n.iterator() )
#set($first = true)
#foreach( $s in $i.descr() )
#if( $first )
#set($first = false)
		/// <param name="$i.name()"> $s </param>
#else
		/// $s
#end
#end
#end
		///
		public $n.name()
		(
#set( $sep = "" )
#foreach( $i in $n.iterator() )
			$sep$helper.getTypeName( $i.type() ) $i.name()
#set( $sep = ", " )
#end
		)
		{
#foreach( $i in $n.iterator() )
			this.$i.name() = $i.name();
#end
		}
#end
#if( $n.isExcept() )
		public String GetMessage()
		{
			return $helper.formatString( $n, true );
		}
#else
		public override String ToString()
		{
			return $helper.formatString( $n, false );
		}
#end	
#foreach( $i in $n.iterator() )
		///
#foreach( $s in $i.descr() )
		/// $s
#end
		///
		public $helper.getTypeName( $i.type() ) $i.name();
#end
	}	
#end
#end
#end
}
}