// This file automatically generated by:
//   $version
//   $now
#set($i = $intf.name())

namespace $intf.parent().name()
{


using System;
using Etch.Msg;
using Etch.Transport;
using Etch.Support;

#if (!$hasBaseClass)
// using Etch.Support.StubBase;
#end
#foreach( $n in $intf.iterator() )
#if ($n.isExtern())
#if ($n.hasImport( $helper ))
using $n.getImport( $helper );
#end
#end
#end

///
///<summary> Message to call translator for $i$suffix. </summary>
///
#if ($hasBaseClass)
public class Stub$i$suffix : Stub$i
#else
public class Stub$i$suffix : StubBase
#end
{
	///
	/// <summary>Stub for $i$suffix.</summary>
	/// <param name="obj"> the implementation of $i$suffix responsive to requests.</param>
	/// <param name="queued"> thread pool used to run AsyncReceiverMode.QUEUED methods.</param>
	/// <param name="free"> thread pool used to run AsyncReceiverMode.FREE methods..</param>
	///
	public Stub$i$suffix( MessageSource src, $i$suffix obj, Pool queued, Pool free ) : base( src, obj, queued, free )
	{	
		this._obj = obj;
	}
	
	private $i$suffix _obj;

	public override bool Message( Who _sender, Message _msg ) 
	{
		if (_msg == null)
		{
			base.Message( _sender, _msg );
			return true;
		}

		switch (_msg.GetXType.Id)
		{
#foreach( $mthd in $intf.iterator() )
#if ($mthd.isMsgDir($mc))
#if (!$mthd.isHidden())
			case $mthd.id(): // ValueFactory$i.$mthd.vname( $helper )
#if ($mthd.isAsyncReceiver())
				_${helper.asyncReceiverPoolName( $mthd )}.Run( delegate() {
#end
				do_$mthd.name()( _sender, _msg );
#if ($mthd.isAsyncReceiver())
				  }, delegate( Exception e ){ } );
#end
				return true;
#end
#end
#end
			default:
				return base.Message(  _sender, _msg );
		}
	}
#foreach( $mthd in $intf.iterator() )
#if ($mthd.isMsgDir($mc))
#if (!$mthd.isHidden())

	///
	/// <param name="_src"></param>
	/// <param name="_sender"></param>
	/// <param name="_msg"></param>
	/// Exception:
	///		throws Exception	
	///
	void do_$mthd.name()( Who _sender, Message _msg )
	{
		try
		{
#foreach ($param in $mthd.iterator())

			$helper.getTypeName( $param.type() ) $param.name() = 
				($helper.getTypeName( $param.type() ))
#if ($param.type().dim() > 0)
				// ValueFactory${i}.to_$param.type().type()(
				//	typeof( ${helper.getTypeName( $param.type() )} ),
#end
					_msg.Get( ValueFactory$i.$param.vname( $helper ) );
#if ($param.type().dim() > 0)
				//)
#end
				;
#end

#if ($mthd.hasAuth())
#set( $auth = $mthd.getAuth() )
			if ((bool)!_obj.${auth.method()}(
#set( $sep = "" )
#foreach($arg in $auth.args())
#if ($arg.isLiteralConstant())
				($helper.getNativeTypeName( $arg.type() )) $sep$helper.getTypeValue( $arg.type(), $arg.value() )
#elseif ($arg.isParameter( $mthd ))
				$sep$helper.qualifyParameterName( $arg.value() )
#elseif ($arg.isConstant( $intf ))
				$sep$helper.qualifyConstantName( $intf, $arg.value() )
#elseif ($arg.isEnum( $intf ))
				$sep$helper.qualifyEnumName( $intf, $arg.value() )
#else
				${sep}null
#end
#set( $sep = ", " )
#end
			)) throw new _Etch_AuthException( "$mthd.name()" );
#end
#if ($mthd.hasReturn())
			Object _result =
#end
			_obj.$mthd.name()(
#set( $sep = "" )
#foreach ($param in $mthd.iterator())
				$sep$param.name()
#set( $sep = ", " )
#end
			);
#if (!$mthd.isOneway())

			Message _rmsg = _msg.Reply();
#if ($mthd.hasReturn())
			_rmsg.Add( ValueFactory$i._mf_result, _result );
#end
			_src.Messagex( _sender, _rmsg );
#end
		}
		catch ( Exception e )
		{
#if (!$mthd.isOneway())
			Message _rmsg = _msg.Reply();
#else
			Message _rmsg = _msg.Reply( ValueFactory$i._mt__exception );
#end
			_rmsg.Add( ValueFactory$i._mf_result, e );
			_src.Messagex( _sender, _rmsg );
		}
	}
#end
#end
#end
}

}