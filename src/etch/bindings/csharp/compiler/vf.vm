// This file automatically generated by: 
// $version. 
// $now.

namespace $intf.parent().name()
{
using System;
using System.Collections.Generic;
using Etch.Msg;
using Etch.Support;
#foreach( $n in $intf.iterator() )
#if ($n.isExtern())
#if ($n.hasImport( $helper ))
using $n.getImport( $helper );
#end
#if ($n.hasSerializerImport( $helper ))
using $n.getSerializerImport( $helper );
#end
#end
#end

///
///<summary> ValueFactory for $intf.name(). </summary>
///
public class ValueFactory$intf.name() : DefaultValueFactory
{
	private readonly static TypeMap types = new TypeMap();
    
    private readonly static FieldMap fields = new FieldMap();

	/// 
	/// <summary>Static constructor</summary>
	///
	static ValueFactory$intf.name()()
	{
		DefaultValueFactory.Init(types,fields);
		
#foreach ( $n in $intf.iterator() )
#if ($n.isMessage())
#if (!$n.isHidden())
#if (!$n.isOneway())
#set($r = $n.getResultMessage())
		${n.vname( $helper )}.SetResult( $r.vname( $helper ) );
#end
#end
#end
#end
		
		
		// initialize the extern serializers:
#foreach( $n in $intf.iterator() )
#if ($n.isExtern())
		${n.sname( $helper )}.Init( fields, $n.vname( $helper ) );
#end
#end

		// done updating types and fields, lock them.
		types.Lock();
		fields.Lock();

#foreach( $n in $intf.iterator() )
#if ($n.isEnumx() || $n.isStruct() || $n.isExcept() || $n.isMessage())

		// params for $n.name()
#foreach( $param in $n.iterator() )
		${n.vname( $helper )}.PutValidator( $param.vname( $helper ), $helper.getValidator( $param ) );
#end
#if ($n.isMessage())
		${n.vname( $helper )}.PutValidator( _mf__messageId, Validator_long.Get( 0 ) );
#if ($n.isHidden())
#set( $param = $n.getResultParam() )
#set( $reqMsg = $n.getRequestMessage() )
#foreach( $t in $reqMsg.thrown().iterator() )
		${n.vname( $helper )}.PutValidator( $param.vname( $helper ), $helper.getValidator( $t ) ); // thrown $t.name()
#end
		${n.vname( $helper )}.PutValidator( $param.vname( $helper ), Validator_RuntimeException.Get() ); // thrown RuntimeException
		${n.vname( $helper )}.PutValidator( _mf__inReplyTo, Validator_long.Get( 0 ) );
#end
#end


#end
#end
	
	} // end of static constructor
	
	/// <summary>
	/// Construct the ValueFactory${intf.name()}.
	/// </summary>
	public ValueFactory$intf.name()()
	{
		
	}
#foreach ( $n in $intf.iterator() )
#if ($n.isEnumx() || $n.isStruct() || $n.isExtern() || $n.isExcept() || $n.isMessage())
	/// Type for $n.fqname() 
	public static XType $n.vname( $helper ) =  types.Get( "$n.fqname()" );

#end
#end
## ---------------------------------------------------------------------------
	
	public override XType GetType(String name )
	{
		return types.Get( name );
	}
	
	public override ICollection<XType> GetTypes()
	{
		return types.Values();
	}
	
	public override XType GetType( int? id )
	{
		return types.Get( id );
	}

	public override StructValue ExportCustomValue( Object value )
	{
		Type clss = value.GetType();

#foreach ( $n in $intf.iterator() )
#if ($n.isStruct() || $n.isExcept())
#set( $tname = $n.efqname( $helper ) )
		if (clss == typeof(${tname}))
		{
			StructValue sv = new StructValue( $n.vname( $helper ) );
			$tname v = ($tname) value;
#foreach( $param in $n.iterator() )
			sv.Add( $param.vname( $helper ), v.$param.name() );
#end
			return sv;
		}

#elseif ($n.isExtern())
#set( $tname = $n.efqname( $helper ) )
		if (clss == typeof(${tname}))
		{
			StructValue sv = new StructValue( $n.vname( $helper ) );
			// serialize $tname to struct using $n.sname( $helper )
			${n.sname( $helper )}.ExportValue( this, ($tname) value, sv );
			return sv;
		}

#elseif ($n.isEnumx())
#set( $tname = $n.efqname( $helper ) )
		if (clss == typeof( ${tname} ) )
		{
			StructValue sv = new StructValue( $n.vname( $helper ) );
			$tname v = ($tname) value;
			switch (v)
			{
#foreach ($p in $n.iterator())
				case $tname.$p.name(): sv.Add( $p.vname( $helper ), true ); break;
#end
			}
			return sv;
		}

#end
#end
		return base.ExportCustomValue( value );
	}

	
	public override Object ImportCustomValue( StructValue sv )
	{
		XType type = sv.GetXType;
#foreach ( $n in $intf.iterator() )
#if ($n.isEnumx())
#set( $tname = $n.efqname( $helper ) )

		if (type == $n.vname( $helper )) // enum
		{
			// assume there is a single key
			Field key = null;
			IEnumerator<Field> myEnum = sv.Keys.GetEnumerator();
			if (myEnum.MoveNext())
				key = myEnum.Current;
			
#foreach ($p in $n.iterator())
			if (key == $p.vname( $helper )) return ${tname}.$p.name();
#end
			return null;
		}
#elseif ($n.isStruct() || $n.isExcept())
#set( $tname = $n.efqname( $helper ) )

		if (type == $n.vname( $helper )) // struct/except
		{
			return new $tname(
#set( $sep = "" )
#foreach ($p in $n.iterator())
				${sep}($helper.getTypeName( $p.type() ))
					sv.Get( $p.vname( $helper ) )
#set( $sep = ", " )
#end
			);
		}
#elseif ($n.isExtern())
#set( $tname = $n.efqname( $helper ) )

		if (type == $n.vname( $helper )) // extern
		{
			// deserialize $tname from struct using $n.sname( $helper )
			return ${n.sname( $helper )}.ImportValue( this, sv );
		}
#end
#end

		return base.ImportCustomValue( sv );
	}

	
	public override XType GetCustomStructType( Type c )
	{
		//if (c == Date.class) return _mt__Etch_Date;
#foreach ( $n in $intf.iterator() )
#if ($n.isEnumx() || $n.isStruct() || $n.isExtern() || $n.isExcept())
#set( $tname = $n.efqname( $helper ) )
		if (c == typeof(${tname})) return $n.vname( $helper );
#end
#end
		return base.GetCustomStructType( c );
	}

	
	public override Type GetCustomType( XType type )
	{
//			case -1201742561 /* _mt__Etch_Date */: return typeof(DateTime);
#foreach ( $n in $intf.iterator() )
#if ($n.isEnumx() || $n.isStruct() || $n.isExtern() || $n.isExcept())
#set( $tname = $n.efqname( $helper ) )
			if (type == $n.vname( $helper )) return typeof( ${tname} );
#end
#end
		return base.GetCustomType( type );
	}
	
#set( $x = $params.clear() )
#foreach( $n in $intf.iterator() )
#if ($n.isEnumx() || $n.isStruct() || $n.isExcept() || $n.isMessage())
#foreach( $param in $n.iterator() )
#if (!$params.contains($param.name().name()))
#set( $x = $params.add($param.name().name()) )
	/// Field for $param.name().name() 
	public static Field $param.vname( $helper ) = fields.Get( "$param.name().name()" );
	
	//public static Field $param.vname( $helper ) = new Field( $param.id(), "$param.name().name()" );
	//{ addField( $param.vname( $helper ) ); }
	
#end
#end
#end
#end
##

	public override Field GetField( int? id )
	{
		return fields.Get( id );
	}
	
	
	public override Field GetField( String name )
	{
		return fields.Get( name );
	}
	
	public override ICollection<Field> GetFields()
	{
		return fields.Values();
	}
}

}