## Copyright 2007-2008 Cisco Systems Inc.
##
## Licensed under the Apache License, Version 2.0 (the "License"); you may not
## use this file except in compliance with the License. You may obtain a copy
## of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing, software
## distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
## WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
## License for the specific language governing permissions and limitations
## under the License.
// This file automatically generated by:
//   $version
//   $now
// This file is automatically created and should not be edited!
#set($i = $intf.name())

using Etch.Msg;
using Etch.Support;
using Etch.Util;

/// <summary>
/// Transport helper for ${i}.
/// </summary>
namespace $intf.parent().name()
{
    public class ${i}Helper : TransportHelper
    {
#if ( $helper.isServer($mc) || $helper.isBoth($mc) )

		/// <summary>Constructs a new server session listener per specifications
		/// in uri and resources.</summary>
		/// <param name="uri"> contains specifications for the server session
		/// listener and for the server session transport stack.</param>
		/// <param name="resources"> additional resources to aid in constructing
		/// new server sessions.</param>
		/// <param name="implFactory"> called upon accepting a new server session to
		/// construct a new server implementation to handle messages
		/// from the client during the session.</param>
		/// <returns> an out-of-band source that may be used to control
		/// the listener.</returns>

		public static Transport<ServerFactory> NewListener( string uri,		
			Resources resources, ${i}ServerFactory implFactory )
		{
			Resources res = InitResources( resources );
			return TransportFactory.GetListener( uri, res,
				new MyServerFactory( uri, res, implFactory ) );
		}
		
		public class MyServerFactory : DefaultServerFactory
		{
			private readonly string _uri;
			private readonly Resources _resources;
			private readonly ${i}ServerFactory _implFactory;
			
			public MyServerFactory( string uri, Resources resources, ${i}ServerFactory implFactory )
				: base(implFactory)
			{
				_uri = uri;
				_resources = resources;
				_implFactory = implFactory;
			}
		
			public override void NewServer( DeliveryService d, ValueFactory vf )
			{
				Remote${i}Client client = new Remote${i}Client( d, vf );
				${i}Server server = _implFactory.New${i}Server( client );
				Pool qp = (Pool) _resources[ QUEUED_POOL ];
				Pool fp = (Pool) _resources[ FREE_POOL ];
				new Stub${i}Server( d, server, qp, fp );
			}

            public override ValueFactory NewValueFactory()
            {
                return new ValueFactory${i}(_uri);
            }
		}
		
		/// <summary>
		/// Factory for a Listener to use to create new instances of ${i}Server.
		/// </summary>
		
		public interface ${i}ServerFactory
		{
			/// <param name="client"> an Remote${i}Client instance for server implementation
			/// to use to call back to the client.</param>
			/// <returns> an instance of ${i}Server (e.g., Impl${i}Server) to
			/// handle messages which arrive from the client.</returns>
			
			${i}Server New${i}Server( Remote${i}Client client );
		}		
#end
#if ( $helper.isClient($mc) || $helper.isBoth($mc) )

		/// <summary>Constructs a new client session per specifications in uri
		/// and resources.</summary>
		/// <param name="uri"> contains specifications for the client session
		/// transport stack.</param>
		/// <param name="resources"> additional resources to aid in constructing
		/// new sessions.</param>
		/// <param name="implFactory">factory used to construct a new instance implementing
		/// ${i}Client. The new instance will receive and process messages from the
		///	server session.</param>
		/// <returns> new remote server instance initialized by uri
		/// and resources which may be used to send messages to the
		/// server session.</returns>
		
		public static Remote${i}Server NewServer( string uri,
			Resources resources, ${i}ClientFactory implFactory )
		{
			resources = InitResources( resources );
			ValueFactory${i} vf= new ValueFactory${i}(uri);
			resources.Add( TransportConsts.VALUE_FACTORY, vf );
			DeliveryService d = TransportFactory.GetTransport( uri, resources );
			Remote${i}Server server = new Remote${i}Server( d, vf );
			${i}Client client = implFactory.New${i}Client( server );			
			 new Stub${i}Client( d,
					client,
					(Pool) resources[ QUEUED_POOL ],
					(Pool) resources[ FREE_POOL ] );
	
			return server;
		}
		
		///<summary>
		///Factory used by
		///{@link ${i}Helper#new${i}Server(String, Resources, ${i}ClientFactory)}
		///to construct a new instance implementing {@link ${i}Client}. The new
		///instance will receive and process messages from the server session.
		///</summary>
		
		public interface ${i}ClientFactory
		{
			///<summary>
			///Constructs a new instance implementing ${i}Client. The new
			///instance will receive and process messages from the server session.</summary>
		 	///<param name=server> an instance of Remote${i}Server which may be used to
			/// send messages to the server session. </param>
			///<returns> new instance implementing ${i}Client (typically
			///Impl${i}Client). </returns>
			
			${i}Client New${i}Client( Remote${i}Server server );			
		}
#end
	}
}
