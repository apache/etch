## Licensed to the Apache Software Foundation (ASF) under one
## or more contributor license agreements. See the NOTICE file
## distributed with this work for additional information
## regarding copyright ownership. The ASF licenses this file
## to you under the Apache License, Version 2.0 (the
## "License"); you may not use this file except in compliance
## with the License. You may obtain a copy of the License at
##
##   http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing,
## software distributed under the License is distributed on an
## "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
## KIND, either express or implied. See the License for the
## specific language governing permissions and limitations
## under the License.
// This file automatically generated by:
//   $version
//   $now
// This file is automatically created and should not be edited!
#set($i = $intf.name())

#set($intfname = "$i$suffix")
#set($baseclname = "Base$intfname")
#set($implname = "Impl$intfname")

package $helper.getPackageName($intf)

#set ($hasMethod = false)
#foreach($n in $intf.iterator())
#if($n.isMsgDir($mc))
#if(!$n.isHidden())
#set ($hasMethod = true)
#end
#end
#end

#if ($hasMethod == true || $hasBaseClass)
import "etch"
#end

#if ($hasBaseClass)
func SetStubHelpers_Stub$i$suffix (dvf etch.ValueFactory) {
     SetStubHelpers_Stub$i()
#set( $T = "$i$suffix" )
#else
func SetStubHelpers_Stub$i$suffix () {
#set( $T = "T" )
#end
#foreach( $mthd in $intf.iterator() )
#if ($mthd.isMsgDir($mc))
#if (!$mthd.isHidden())
    if dvf.GetTypeByName("$mthd.fqname()").StubHelper == nil {
	dvf.GetTypeByName("$mthd.fqname()").StubHelper = new($mthd.vname( $helper )Helper)
    }
#end
#end
#end
}	

#foreach( $mthd in $intf.iterator() )
#if ($mthd.isMsgDir($mc))
#if (!$mthd.isHidden())

type $mthd.vname( $helper )Helper struct{}

func (dh *$mthd.vname( $helper )Helper) Run(svc etch.DeliveryService, impl interface{}, sender interface{}, msg *etch.Message) {
#if (!$mthd.isOneway())
    rmsg := msg.Reply()
#end
    di := impl.(*$implname)
#foreach ($param in $mthd.iterator())
    $param.name() := msg.Vf.(*ValueFactory$i).$param.vname( $helper ) ;
#end

#foreach ($param in $mthd.iterator()) 
    val_$param.name() := msg.Fields[$param.name()]
#if ($helper.getTypeName( $param.type() ).startsWith("*"))
    var $param.name()_param $helper.getTypeName( $param.type() ) = nil
    if val_$param.name() != nil  {
       $param.name()_param = val_$param.name().($helper.getTypeName( $param.type() ))
    }
#elseif ($helper.getTypeName( $param.type() ).startsWith("int"))
    var $param.name()_param $helper.getTypeName( $param.type() ) = etch.To$helper.getTypeName( $param.type() )(val_$param.name())
#else
    var $param.name()_param $helper.getTypeName( $param.type() ) = val_$param.name().($helper.getTypeName( $param.type() ))
#end
#end

#set ($returnPrefix = "")
#if ($mthd.hasReturn())
#set ($returnPrefix = "ret :=")
#end
#set ($callName = "di.$mthd.name()(")
#set( $sep = "" )
#foreach ($param in $mthd.iterator())
#set ($callName = $callName + "${sep}$param.name()_param")
#set( $sep = ", " )
#end
#set ($callName = $callName + ")")
    $returnPrefix $callName
#if ($mthd.hasReturn())
    rmsg.Put(msg.Vf.GetDefaultResponseField(), ret)
#end
#if (!$mthd.isOneway())
    svc.TransportMessage(sender, rmsg)
#end
}

#end
#end
#end
