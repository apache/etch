## Licensed to the Apache Software Foundation (ASF) under one
## or more contributor license agreements. See the NOTICE file
## distributed with this work for additional information
## regarding copyright ownership. The ASF licenses this file
## to you under the Apache License, Version 2.0 (the
## "License"); you may not use this file except in compliance
## with the License. You may obtain a copy of the License at
##
##   http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing,
## software distributed under the License is distributed on an
## "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
## KIND, either express or implied. See the License for the
## specific language governing permissions and limitations
## under the License.
// This file automatically generated by:
//   $version
//   $now
// This file is automatically created and should not be edited!
#set($i = $intf.name())
#set($vfname = "ValueFactory$i")
#set($intfname = "$i$suffix")
#set($clname = "Remote$intfname")

package $intf.parent().name();

#foreach( $n in $intf.iterator() )
#if($n.isExtern())
#if($n.hasImport( $helper ))
import $n.getImport( $helper );
#end
#end
#end

/**
 * Call to message translator for $intfname.
 */
@SuppressWarnings("unused")
#if($hasBaseClass)
public final class $clname extends Remote$i implements $intfname
#else
public class $clname extends org.apache.etch.bindings.java.support.RemoteBase implements $intfname
#end
{
	/**
	 * Constructs the $clname.
	 *
	 * @param svc
	 * @param vf
	 */
	public $clname( org.apache.etch.bindings.java.support.DeliveryService svc, org.apache.etch.bindings.java.msg.ValueFactory vf )
	{
		super( svc, vf );
#set( $k = 0 )
#foreach( $x in $intf.iterator() )
#if( $x.isMixin() )
#set( $k = $k + 1 )
#set( $v = "_mixin$k" )
#set( $m = $x.getModule() )
#set( $z = $m.iterator().next() )
		$v = new ${m.name()}.Remote$z.name()${suffix}( svc, vf );
#end
#end
	}

	/**
	 * {@link _Async} class instance used to hide asynchronous message
	 * implementation. Use this to invoke the asynchronous message
	 * implementations.
	 */
	public final _Async _async = new _Async();

	/**
	 * {@link _Async} class instance used to hide asynchronous message
	 * implementation. This is here for backwards compatibility only, use
	 * {@link #_async} instead.
	 * @deprecated
	 */
	@Deprecated
	public final _Async _inner = _async;
#foreach($n in $intf.iterator())
#if($n.isMsgDir($mc))
#if(!$n.isHidden())
#if(!$methodList.contains($n.name().name()))
#set ( $addMethodListStatus = $methodList.add($n.name().name()))
#if($n.isOneway())

	public final $helper.getTypeName( $n.type() ) $n.name()(
#set( $sep = "" )
#foreach( $p in $n.iterator() )
		$sep$helper.getTypeName( $p.type() ) $p.name()
#set( $sep = ", " )
#end
	)
	{
		org.apache.etch.bindings.java.msg.Message _msg = _newMessage( $vfname.$n.vname( $helper ) );
#foreach( $p in $n.iterator() )
		_msg.put( $vfname.$p.vname( $helper ), $p.name() );
#end
		try
		{
			_send( _msg );
		}
		catch ( Exception _e )
		{
			if (_e instanceof RuntimeException) throw (RuntimeException) _e;
			throw new RuntimeException( "unexpected exception from peer: "+_e, _e );
		}
	}
#else

	public final $helper.getTypeName( $n.type() ) $n.name()(
#set( $sep = "" )
#foreach( $p in $n.iterator() )
		$sep$helper.getTypeName( $p.type() ) $p.name()
#set( $sep = ", " )
#end
	)
#if($n.thrown().iterator().hasNext())
	throws
#set( $sep = "" )
#foreach($t in $n.thrown().iterator())
		$sep$t.getNamed().fqname()
#set( $sep = ", " )
#end
#end
	{
#if($n.hasReturn())
		return
#end
		_async._end_${n.name()}( _async._begin_${n.name()}(
#set( $sep = "" )
#foreach( $p in $n.iterator() )
			$sep$p.name()
#set( $sep = ", " )
#end
		) );
	}
#end
#end
#end
#end
#end
#set( $k = 0 )
#foreach( $x in $intf.iterator() )
#if( $x.isMixin() )

	// ----- mixin $x.name() ----- //
#set( $k = $k + 1 )
#set( $v = "_mixin$k" )
#set( $m = $x.getModule() )
#set( $z = $m.iterator().next() )

	private final ${m.name()}.Remote$z.name()$suffix $v;
#foreach( $n in $z.messages( true ) )
#if($n.isMsgDir($mc))
#if(!$n.isHidden())
#if(!$methodList.contains($n.name().name()))
#set ( $addMethodListStatus = $methodList.add($n.name().name()) )
	// --- generated methods for $n.name() --- //

#if($n.isOneway())
	public final $helper.getTypeName( $n.type() ) $n.name()(
#set( $sep = "" )
#foreach( $p in $n.iterator() )
		$sep$helper.getTypeName( $p.type() ) $p.name()
#set( $sep = ", " )
#end
	)
	{
		${v}.$n.name()(
#set( $sep = "" )
#foreach( $p in $n.iterator() )
			$sep$p.name()
#set( $sep = ", " )
#end
		);
	}
#else
	public final $helper.getTypeName( $n.type() ) $n.name()(
#set( $sep = "" )
#foreach( $p in $n.iterator() )
		$sep$helper.getTypeName( $p.type() ) $p.name()
#set( $sep = ", " )
#end
	)
#if($n.thrown().iterator().hasNext())
	throws
#set( $sep = "" )
#foreach($t in $n.thrown().iterator())
		$sep$t.getNamed().fqname()
#set( $sep = ", " )
#end
#end
	{
#if($n.hasReturn())
		return
#end
		${v}.$n.name()(
#set( $sep = "" )
#foreach( $p in $n.iterator() )
			$sep$p.name()
#set( $sep = ", " )
#end
		);
	}
#end
#end
#end
#end
#end
#end
#end

	/**
	 * Asynchronous implementation of service methods.
	 */
#if($hasBaseClass)
	public final class _Async extends Remote${i}._Async
#else
	public class _Async
#end
	{
#foreach($n in $intf.iterator())
#if($n.isMsgDir($mc))
#if(!$n.isHidden())
#if(!$methodList.contains("_begin_end_$n.name().name()"))
#set ( $addMethodListStatus = $methodList.add("_begin_end_$n.name().name()") )
#if(!$n.isOneway())

		/**
		 * Begins a call to ${n.name()}.
		 *
#foreach( $s in $n.descr() )
		 * $s
#end
#foreach( $p in $n.iterator() )
#set($sep = "@param $p.name() ")
#foreach( $s in $p.descr() )
		 * $sep$s
#set($sep = "")
#end
#end
		 * @return mailbox used to retrieve the result using _end_${n.name()}.
		 * @see $clname#${n.name()}
		 * @see #_end_${n.name()}
		 */
		public final org.apache.etch.bindings.java.support.Mailbox _begin_${n.name()}(
#set( $sep = "" )
#foreach( $p in $n.iterator() )
			$sep$helper.getTypeName( $p.type() ) $p.name()
#set( $sep = ", " )
#end
		)
		{
			org.apache.etch.bindings.java.msg.Message _msg = _newMessage( $vfname.$n.vname( $helper ) );
#foreach( $p in $n.iterator() )
			_msg.put( $vfname.$p.vname( $helper ), $p.name() );
#end
			return _begincall( _msg );
		}
		
		/**
		 * Ends a call to ${n.name()}.
		 *
#foreach( $s in $n.descr() )
		 * $s
#end
		 * @param mb mailbox returned by _begin_${n.name()}.
#if($n.hasReturn())
#set($sep = "@return ")
#foreach( $s in $n.returnDescr() )
		 * $sep$s
#set($sep = "")
#end
#end
#foreach($t in $n.thrown().iterator())
#set($sep = "@throws $t.name() ")
#foreach( $s in $t.descr() )
		 * $sep$s
#set($sep = "")
#end
#end
		 *
		 * @see $clname#${n.name()}
		 * @see #_begin_${n.name()}
		 */
		public final $helper.getTypeName( $n.type() ) _end_${n.name()}( org.apache.etch.bindings.java.support.Mailbox mb )
#if($n.thrown().iterator().hasNext())
			throws
#set( $sep = "" )
#foreach($t in $n.thrown().iterator())
				$sep$t.getNamed().fqname()
#set( $sep = ", " )
#end
#end
		{
			try
			{
#if($n.hasReturn())
				return
					($helper.getTypeName( $n.type() ))
						_endcall( mb,
							$vfname.$n.getResultMessage().vname( $helper ) );
#else
				_endcall( mb,
					$vfname.$n.getResultMessage().vname( $helper )  );
#end
			}
			catch ( Exception e )
			{
#foreach($t in $n.thrown().iterator())
				if (e instanceof ${t.getNamed().fqname()})
					throw ($t.getNamed().fqname()) e;
#end
				if (e instanceof RuntimeException) throw (RuntimeException) e;
				throw new RuntimeException( "unexpected exception from peer: "+e, e );
			}
		}
#end
#end
#end
#end 
#end

		// Mixin Methods
#set( $k = 0 )
#foreach( $x in $intf.iterator() )
#if( $x.isMixin() )
#set( $k = $k + 1 )
#set( $v = "_mixin$k" )
#set( $m = $x.getModule() )
#set( $z = $m.iterator().next() )
#foreach( $n in $z.messages( true ) )
#if($n.isMsgDir($mc))
#if(!$n.isHidden())
#if(!$methodList.contains("_begin_end_$n.name().name()"))
#set ( $addMethodListStatus = $methodList.add("_begin_end_$n.name().name()") )
		// --- generated methods for $n.name() --- //

#if(!$n.isOneway())
		/**
		 * Begins a call to ${n.name()}.
		 *
#foreach( $s in $n.descr() )
		 * $s
#end
#foreach( $p in $n.iterator() )
#set( $sep = "@param $p.name() " )
#foreach( $s in $p.descr() )
		 * $sep$s
#set( $sep = "" )
#end
#end
		 * @return mailbox used to retrieve the result using _end_${n.name()}.
		 * @see $clname#${n.name()}
		 * @see #_end_${n.name()}
		 */
		public final org.apache.etch.bindings.java.support.Mailbox _begin_${n.name()}(
#set( $sep = "" )
#foreach( $p in $n.iterator() )
			$sep$helper.getTypeName( $p.type() ) $p.name()
#set( $sep = ", " )
#end
		)
		{
			return ${v}._async._begin_${n.name()}(
#set( $sep = "" )
#foreach( $p in $n.iterator() )
				$sep$p.name()
#set( $sep = ", " )
#end
			);
		}
		
		/**
		 * Ends a call to ${n.name()}.
		 *
#foreach( $s in $n.descr() )
		 * $s
#end
		 * @param mb mailbox returned by _begin_${n.name()}.
#if( $n.hasReturn() )
#set( $sep = "@return " )
#foreach( $s in $n.returnDescr() )
		 * $sep$s
#set( $sep = "" )
#end
#end
#foreach( $t in $n.thrown().iterator() )
#set( $sep = "@throws $t.name() " )
#foreach( $s in $t.descr() )
		 * $sep$s
#set( $sep = "" )
#end
#end
		 *
		 * @see $clname#${n.name()}
		 * @see #_begin_${n.name()}
		 */
		public final $helper.getTypeName( $n.type() ) _end_${n.name()}( org.apache.etch.bindings.java.support.Mailbox mb )
#if($n.thrown().iterator().hasNext())
			throws
#set( $sep = "" )
#foreach($t in $n.thrown().iterator())
				$sep$t.getNamed().fqname()
#set( $sep = ", " )
#end
#end
		{
#if($n.hasReturn())
			return
#end
			${v}._async._end_${n.name()}( mb );
		}
#end
#end
#end
#end
#end
#end
#end
	}
}
