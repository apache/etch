// This file automatically generated by:
//   $version
//   $now

// Include this generated library into your web page
// It is not recommended that you change this file.
new function()
{
	// define the namespace of this service
	var rootNamespace = "$intf.parent().name()";

	// create the namespace in non-obtrusive fashion using namespacer()
	var rootNamespaceParent = namespacer(rootNamespace);
	
	// find all sub-namespaces, and create them
#foreach( $n in $intf.iterator())
#if( $n.isMixin() )
	namespacer("$n.getModule().name()");
#end
#end

	// creates the specified namespace, by creating objects for each name
	// and associating them in a hierarchy.
	function namespacer(namespace)
	{
		var nsBits = namespace.split(".");

		var base = window;

		for(var i = 0; i < nsBits.length; i++)
		{	
			base = createNamespace(base, nsBits[i]);		
		}	
		
		return base;
	}

	function createNamespace(base, nsBit)
	{	

		// If no one has yet created this name, let's go ahead and create it for ourselves as an empty object.
		if(base[nsBit] == null)
		{
			base[nsBit] = {};
		}	

		// someone must have already made it--that's actually OK, as long as the already-constructed type
		// is an object.  Otherwise there isn't much we can do to carry on.
		else if(typeof base[nsBit] != 'object')
		{
			throw "Namespace collision on " + nsBit;
		}
	
		return base[nsBit];
	}

	var $intf.name() = function $intf.name()() 
	{
		var that = this;
		
		try
		{
			this.transport = new etch.poc.Transport(this);
		}
		catch(err)
		{
			// most likely error is Etch Transport library is not included
			throw "Include the Etch transport library in the web page.";
		}
		
		// define callbacks specific to this service.	The assumption is that
		// developers will override these callbacks.
		
		// TODO: avoid name collisions
	}
	
	$intf.name()$helper.prototype()callbacks = {};
	$intf.name()$helper.prototype()parametizer = {};
	$intf.name()$helper.prototype()definitions = {};

	// Establish callback methods.  These are invoked by the parametizer.
#foreach( $n in $intf.iterator() )
#if ($n.isMessage())
#if ($helper.isClientDirected($n.getMessageDirection()))
#if (!$n.isHidden())	$intf.name()$helper.prototype()callbacks.$n.name() = function( #set( $sep = "" )#foreach( $p in $n.iterator() )$sep$p.name() #set( $sep = ", " )#end ) {};#end

#end
#end
#end

#foreach( $n in $intf.iterator())
#if( $n.isMixin() )
#set($module = $n.getModule())
#foreach( $subIntf in $module.iterator())
	// defining callbacks for module $subIntf.fqname()
#foreach( $subItem in $subIntf.iterator() )
#if ($subItem.isMessage())
#if ($helper.isClientDirected($subItem.getMessageDirection()))
#if (!$subItem.isHidden())	$intf.name()$helper.prototype()callbacks.$subItem.name() = function( #set( $sep = "" )#foreach( $p in $subItem.iterator() )$sep$p.name() #set( $sep = ", " )#end ) {};#end

#end
#end
#end
#end
#end
#end

	// Establish parametizer methods.  These take a JSON object, and split out each argument for a given method from that JSON object
#foreach( $n in $intf.iterator() )
#if ($n.isMessage())
#if ($helper.isClientDirected($n.getMessageDirection()))
#if (!$n.isHidden())	$intf.name()$helper.prototype()parametizer["$n.fqname()"] = function(that, args) {
		return that.callbacks.$n.name()(#set( $sep = "" )#foreach( $p in $n.iterator() )$sep args.$p.name() #set( $sep = ", " )#end ); 
	}
#end
#end
#end
#end

#foreach( $n in $intf.iterator())
#if( $n.isMixin() )
#set($module = $n.getModule())
#foreach( $subIntf in $module.iterator())
	// defining parametizers for module $subIntf.fqname()
#foreach( $subItem in $subIntf.iterator() )
#if ($subItem.isMessage())
#if ($helper.isClientDirected($subItem.getMessageDirection()))
#if (!$subItem.isHidden())	$intf.name()$helper.prototype()parametizer["$subItem.fqname()"] = function(that, args) {
		return that.callbacks.$subItem.name()(#set( $sep = "" )#foreach( $p in $subItem.iterator() )$sep args.$p.name() #set( $sep = ", " )#end ); 
	}
#end
#end
#end
#end
#end
#end
#end

	// Establish additional metadata for methods.  Currently, only callbacks are qualified with their 'onewayness'
#foreach( $n in $intf.iterator() )
#if ($n.isMessage())
#if ($helper.isClientDirected($n.getMessageDirection()))
#if (!$n.isHidden())	$intf.name()$helper.prototype()definitions["$n.fqname()"] = { isOneway: $n.isOneway() };
#end
#end
#end
#end

#foreach( $n in $intf.iterator())
#if( $n.isMixin() )
#set($module = $n.getModule())
#foreach( $subIntf in $module.iterator())
	// defining definitions for module $subIntf.fqname()
#foreach( $subItem in $subIntf.iterator() )
#if ($subItem.isMessage())
#if ($helper.isClientDirected($subItem.getMessageDirection()))
#if (!$subItem.isHidden())	$intf.name()$helper.prototype()definitions["$subItem.fqname()"] = { isOneway: $subItem.isOneway() };
#end
#end
#end
#end
#end
#end
#end

	/* Initialize the service and underlying transport */
	$intf.name()$helper.prototype()init = function(host)
	{
		this.transport.init(host);
	}
	
	/* Connect to the server, establishing the Etch session */
	$intf.name()$helper.prototype()connect = function(args)
	{
		this.transport.connect(args);
	}
	
	/* Stop the transport */
	$intf.name()$helper.prototype()stop = function()
	{
		this.transport.stop();
	}
	
	// server-directed methods specific to the $intf.name() service 
#foreach( $n in $intf.iterator() )#if ($n.isMessage())#if ($helper.isServerDirected($n.getMessageDirection()))#if (!$n.isHidden())	
	$intf.name()$helper.prototype()$n.name() = function(args) 
	{
		this.transport.#if($n.isOneway())onewayToServer#end#if(!$n.isOneway())twowayToServer#end(
			"$n.fqname()",
			args,
			$n.getTimeout()); 
	}

#end#end#end#end
	
#foreach( $n in $intf.iterator())
#if( $n.isMixin() )
#set($module = $n.getModule())
#foreach( $subIntf in $module.iterator())
	// defining server-directed methods for module $subIntf.fqname()
#foreach( $subItem in $subIntf.iterator() )#if ($subItem.isMessage())#if ($helper.isServerDirected($subItem.getMessageDirection()))#if (!$subItem.isHidden())	
	$intf.name()$helper.prototype()$subItem.name() = function(args) 
	{
		this.transport.#if($subItem.isOneway())onewayToServer#end#if(!$subItem.isOneway())twowayToServer#end(
			"$subItem.fqname()",
			args,
			$subItem.getTimeout()); 
	}
	
#end#end#end#end#end#end#end
			
	// complex type definitions

#foreach( $n in $intf.iterator() )#if ($n.isStruct() || $n.isExcept())	
	$intf.name()$helper.dot()$n.name() = function $n.name()() 
	{
		this["@type"] = "$n.fqname()";
		
		this.setProperties(arguments);
	}
#if(!$n.hasExtends())
	$helper.localStructPrototype("$intf.name()", "$n.name()") = new etch.poc.BasePrototype;
#else
	$helper.localStructPrototype("$intf.name()", "$n.name()") = new $helper.localJsStructName("$intf.name()", "$n.getExtends().name()");
#end
	$helper.localStructConstructor("$intf.name()", "$n.name()") = $helper.localJsStructName("$intf.name()", "$n.name()");
#foreach( $p in $n.iterator() )
	$helper.localStructProtoField("$intf.name()", "$n.name()", "$p.name()") = null;
#end
	etch.poc.TypeMap["$n.fqname()"] = $helper.localStructConstructor("$intf.name()", "$n.name()");

#end#end


#foreach( $n in $intf.iterator())
#if( $n.isMixin() )
#set($module = $n.getModule())
#foreach( $subIntf in $module.iterator())
	// defining complex type definitions for module $subIntf.fqname()
	$subIntf.fqname() = {};
	var $subIntf.name() = $subIntf.fqname();
#foreach( $subItem in $subIntf.iterator() )
#if ($subItem.isStruct() || $subItem.isExcept())	
	$subIntf.name()$helper.dot()$subItem.name() = function $subItem.name()() 
	{
		this["@type"] = "$subItem.fqname()";
		
		this.setProperties(arguments);
	}
#if(!$subItem.hasExtends())
	$helper.localStructPrototype("$subIntf.name()", "$subItem.name()") = new etch.poc.BasePrototype;
#else
	$helper.localStructPrototype("$subIntf.name()", "$subItem.name()") = new $helper.localJsStructName("$subIntf.name()", "$subItem.getExtends().name()");
#end
	$helper.localStructConstructor("$subIntf.name()", "$subItem.name()") = $helper.localJsStructName("$subIntf.name()", "$subItem.name()");
#foreach( $p in $subItem.iterator() )
	$helper.localStructProtoField("$subIntf.name()", "$subItem.name()", "$p.name()") = null;
#end
	etch.poc.TypeMap["$subItem.fqname()"] = $helper.localStructConstructor("$subIntf.name()", "$subItem.name()");

#end#end

#end#end#end

	// assign the constructed service to it's namespace...
	rootNamespaceParent.$intf.name() = $intf.name();
}
