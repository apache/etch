##
## Licensed to the Apache Software Foundation (ASF) under one
## or more contributor license agreements.  See the NOTICE file
## distributed with this work for additional information
## regarding copyright ownership.  The ASF licenses this file
## to you under the Apache License, Version 2.0 (the
## "License"); you may not use this file except in compliance
## with the License.  You may obtain a copy of the License at
##
##   http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing,
## software distributed under the License is distributed on an
## "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
## KIND, either express or implied.  See the License for the
## specific language governing permissions and limitations
## under the License.
##

// This file automatically generated by:
//   $version
//   $now
// This file is automatically created and should not be edited!

#ifndef __$helper.getIntfName($intf, $mc)_H__
\#define __$helper.getIntfName($intf, $mc)_H__


#set($includedException = 0)
#foreach( $n in $intf.iterator() )
#if($n.isExcept() && ($includedException != 1))
\#include "common/EtchException.h"
#set($includedException = 1)
#end
#end
#if($hasBaseClass)
\#include "$inc"
#else
\#include "common/EtchTypes.h"
#end
\#include "support/EtchAsyncResult.h"
\#include "support/EtchObjectSession.h"

#if ($intf.hasDescr())
/**
#foreach( $s in $intf.descr() )
 * $s
#end
 */
#end

namespace $namespace {
#if($suffix == "")
#set($firstCustomID = true)
  enum EtchObjectCustomTypeIds {
#set($count = 0)
#foreach( $n in $intf.iterator() )
#if ($n.isStruct() || $n.isExcept() || $n.isEnumx())
#set($count = $count +1)
#end
#end
#set($enumHelper = 0)
#foreach( $n in $intf.iterator() )
#if ($n.isStruct() || $n.isExcept() || $n.isEnumx())
#set($enumHelper = $enumHelper + 1)
#if($firstCustomID)
    ${n.vname( $helper )}ID = EOTID_DYNAMIC_START#set($firstCustomID = false),
#else
    ${n.vname( $helper )}ID#if($enumHelper < $count),#end

#end
#end
#end
  };
#end
#foreach( $n in $intf.iterator() )
#if($n.isEnumx())
#if (!$hasBaseClass)
#if ($n.hasDescr())

  /**
#foreach( $s in $n.descr() )
   * $s
#end
   */
#end
  class $n.name() 
  : public EtchObject {
  public:
    static const EtchObjectType* TYPE();
    enum _eval{
#set($count = 0)#foreach($i in $n.iterator())#set($count = $count +1)#end
#set($enumHelper=0) 
#foreach( $i in $n.iterator() )
#set($enumHelper = $enumHelper+1)
      /**
#foreach( $s in $i.descr() )
      * $s
#end
      */
      $n.name()_$i.name()#if($enumHelper < $count),#end

#end

    } Value;

    $n.name()() {
      addObjectType($n.name()::TYPE());
    }
    $n.name()(_eval eval) { 
      addObjectType($n.name()::TYPE());
      Value = eval; 
    }
  };
  typedef capu::SmartPointer<$n.name()> $n.name()Ptr;
#end
#end
#end

#if ($hasBaseClass)
  class $intf.name()$suffix : public virtual $intf.name(), public EtchObjectSession
#else
  class $intf.name()$suffix
#end
#foreach( $n in $intf.iterator() )
#if($n.isConstant() && !$hasBaseClass)
#set($initConstruct = true)
#end
#if ($n.isMixin())
    $sep public $n.name()$suffix
#set ($sep = ",")
#end
#end
  {
#if (!$intf.hasMessageDirection($mc))
    // no $mc direction items defined.
#end

  public:
#if($initConstruct)
    $intf.name()();
#end
    virtual ~$intf.name()$suffix() {}
    
    // default implementation of EtchObjectSession
    virtual status_t _sessionQuery( capu::SmartPointer<EtchObject> query, capu::SmartPointer<EtchObject> &result );
    virtual status_t _sessionControl( capu::SmartPointer<EtchObject> control, capu::SmartPointer<EtchObject> value );
    virtual status_t _sessionNotify( capu::SmartPointer<EtchObject> event );

#foreach( $n in $intf.iterator() )
#if ($n.isMessage())
#if ($n.isMsgDir($mc))
#if (!$n.isHidden())

#if(!($helper.getEtchTypeName($n.type(), true) == "void"))
    typedef capu::SmartPointer<EtchAsyncResult<$helper.getEtchTypeName($n.type(), false)> > $n.name()AsyncResultPtr;
    ## typedef EtchAsyncResult<$helper.getEtchTypeName($n.type(), false)> $n.name()AsyncResult;
#else
    typedef EtchAsyncResultNonePtr $n.name()AsyncResultPtr;
#end

    /**
#foreach( $s in $n.descr() )
     * $s
#end
#foreach( $p in $n.iterator() )
#set($first = true)
#foreach( $s in $p.descr() )
#if ($first)
#set($first = false)
     * @param $p.name() $s
#else
     * $s
#end
#end
#end
#if ($n.hasReturn())
#set($first = true)
#foreach( $s in $n.returnDescr() )
#if ($first)
#set($first = false)
     * @return $s
#else
     * $s
#end
#end
#end
#foreach($t in $n.thrown().iterator())
#set($first = true)
#foreach( $s in $t.descr() )
#if ($first)
#set($first = false)
     * @throws $t.name() $s
#else
     * $s
#end
#end
#end
     */
    virtual $n.name()AsyncResultPtr $n.name()(#set( $sep = "" )#foreach($p in $n.iterator())$sep$helper.getEtchTypeName($p.type(), true) $p.name() #set( $sep = ", " )#end) = 0;

#end
#end
#elseif ($n.isConstant())
#if (!$hasBaseClass)
#if ($n.hasDescr())
    /**
#foreach($s in $n.descr())
     * $s
#end
     */
#end
  public:
    $helper.getEtchTypeName($n.type(), false) $n.name();
#end
#elseif ($n.isExtern())
## ignore extern
#elseif ($n.isMixin())
## ignore mixin
#elseif ($n.isStruct() || $n.isExcept())
#if (!$hasBaseClass)
#if ($n.hasDescr())
    /**
#foreach( $s in $n.descr() )
     * $s
#end
     */
#end
    class $n.name()
#if($n.hasExtends())
      : public $n.getExtends().name()
#elseif($n.isExcept())
      : public EtchException
#else
      : public EtchObject
#end
    {
    public:
      static const EtchObjectType* TYPE();

      /**
       * Constructs the $n.name().
       */
      $n.name()();

#if ($n.hasAnyParameters())

      /**
       * Constructs the $n.name().
#foreach( $i in $n.getAllParameters() )
#set( $sep = "@param " )
#foreach( $s in $i.descr() )
       * $sep$i.name() $s
#set( $sep = "" )
#end
#end
       */
      $n.name()(#set($sep = "")#foreach($i in $n.getAllParameters())$sep$helper.getEtchTypeName($i.type(), true) $i.name() #set( $sep = ", " )#end);
#end

      virtual ~$n.name()() {}

#if(! $n.isExcept() )
      EtchStringPtr toString();
#end
#foreach($i in $n.iterator())

#if( $i.hasDescr())
      /**
#foreach($s in $i.descr())
       * $s
#end
       */
#end
    private:
      $helper.getEtchTypeName($i.type(), true) $i.name();

      /**
       * Gets the value.
       *
#foreach($s in $i.descr())
       * $s
#end
       *
       * @return the value.
       */
    public:
      $helper.getEtchTypeName($i.type(), true) $helper.getGetterName($i.name())();

      /**
       * Sets the value.
       *
#foreach($s in $i.descr())
       * $s
#end
       *
       * @param value the value.
       */
    public:
      void $helper.getSetterName($i.name())($helper.getEtchTypeName( $i.type(), true) value);
#end
    };
    typedef capu::SmartPointer<${n.name()}> $n.name()Ptr;
    //TODO: we may not be able to serialize NativeArrays of custom user Types! 
    typedef capu::SmartPointer<EtchNativeArray<${n.name()}Ptr> > EtchNativeArray$n.name()Ptr;

#end
#elseif ($n.isBuiltin())
## nothing to do.
#elseif ($n.isEnumx())
    typedef capu::SmartPointer<${n.name()}> $n.name()Ptr;
    typedef capu::SmartPointer<EtchNativeArray<${n.name()}Ptr> > EtchNativeArray$n.name()Ptr;

#else
    *** intf.vm: don't know what to do with $n ***
#end
#end
  };
}

#endif
