##
## Licensed to the Apache Software Foundation (ASF) under one
## or more contributor license agreements.  See the NOTICE file
## distributed with this work for additional information
## regarding copyright ownership.  The ASF licenses this file
## to you under the Apache License, Version 2.0 (the
## "License"); you may not use this file except in compliance
## with the License.  You may obtain a copy of the License at
##
##   http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing,
## software distributed under the License is distributed on an
## "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
## KIND, either express or implied.  See the License for the
## specific language governing permissions and limitations
## under the License.
##
// This file automatically generated by:
//   $version
//   $now
// This file is automatically created and should not be edited!
#set($i = $intf.name())
#set( $vf = "ValueFactory$intf.name()" )

#ifndef __$helper.getVfName($intf).toUpperCase()_H__
\#define __$helper.getVfName($intf).toUpperCase()_H__

\#include "capu/os/Mutex.h"
\#include "capu/container/List.h"
\#include "common/EtchTypes.h"
\#include "serialization/EtchDefaultValueFactory.h"
\#include "support/EtchRuntime.h"


namespace $namespace {
  /**
   * ValueFactory for $intf.name().
   */
  class $vf : public EtchDefaultValueFactory
  {

    /**
    * Constructs ${vf}.
    * @param uri the uri used to configure the session.
    */
  public:
    ${vf}( EtchString uri );
#foreach ( $n in $intf.iterator() )
#if ($n.isEnumx() || $n.isStruct() || $n.isExtern() || $n.isExcept() || $n.isMessage())

    /** Type for $n.fqname() */
    static EtchType* ${n.vname( $helper )};
#end
#end

#set( $x = $params.clear() )
## standard params from DefaultValueFactory
#set( $x = $params.add( "msg" ) )
#set( $x = $params.add( "result" ) )
#foreach( $n in $intf.iterator() )
#if ($n.isEnumx() || $n.isStruct() || $n.isExcept() || $n.isMessage())
#foreach( $param in $n.iterator() )
#if (!$params.contains($param.name().name()))
#set( $x = $params.add($param.name().name()) )

    /** Field for $param.name().name() */
    static EtchField& $param.vname($helper)();
#end
#end
#end
#end


  private:
    static EtchTypeMap* types();
    static EtchClass2TypeMap* class2type();

    static status_t InitTypes();
    static status_t InitResults();
    static status_t InitFields();
    static status_t InitParams(EtchRuntime* runtime);
#set( $ctr = 0 )
#foreach( $n in $intf.iterator() )
#if ($n.isEnumx() || $n.isStruct() || $n.isExcept() || $n.isMessage())
#if ($ctr > 0 && $ctr % 10 == 0)
    static status_t InitParams${ctr}(EtchRuntime* runtime);
#end
#set( $ctr = $ctr + 1 )
#end
#end
    static status_t InitImportExport(EtchRuntime* runtime);

    status_t getNativeArrayForComponentType(const EtchObjectType *objectType,  capu::SmartPointer<EtchNativeArrayBase> &nativeArray, capu::int32_t length, capu::int32_t dim);


    /**
     * Static Initialization-Helper
     */
  private:
    /**
     * Listener which reacts to changes in runtime
     * Destroys the statically initialized members if the last runtime has been deleted 
     */
    class Etch${i}RuntimeListener : public EtchRuntimeListener {
      /**
       * @see EtchRuntime
       */
      status_t onRuntimeChanged(EtchRuntime* runtime);
    };

    friend class ${i}Helper;
    friend class Etch${i}RuntimeListener;
    static status_t InitValueFactory(EtchRuntime* runtime);
    static capu::Mutex SRuntimesMutex;
    static capu::List<capu::uint64_t> SRuntimes;
    static Etch${i}RuntimeListener S${i}RuntimeListener;
  };
}
#endif
