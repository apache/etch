##
## Licensed to the Apache Software Foundation (ASF) under one
## or more contributor license agreements.  See the NOTICE file
## distributed with this work for additional information
## regarding copyright ownership.  The ASF licenses this file
## to you under the Apache License, Version 2.0 (the
## "License"); you may not use this file except in compliance
## with the License.  You may obtain a copy of the License at
##
##   http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing,
## software distributed under the License is distributed on an
## "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
## KIND, either express or implied.  See the License for the
## specific language governing permissions and limitations
## under the License.
##

// This file automatically generated by:
//   $version
//   $now
// This file is automatically created and should not be edited!

#set($i = $intf.name().name().toLowerCase()) 

/*
 * ${i}_helper.c 
 * transport helper for ${i} service
 */
\#include "$helper.getIntfFileNameH($intf)"

#if($helper.isServer($mc))
\#include "${i}_server.h"
\#include "${i}_server_stub.h"
\#include "${i}_remote_client.h"
#end
#if($helper.isClient($mc))
\#include "${i}_client_stub.h"
\#include "${i}_remote_server.h"
#end

\#include "${i}_helper.h"
\#include "${i}_valufact.h"
\#include "etch_svcobj_masks.h"
\#include "etch_objecttypes.h"
\#include "etch_url.h" 
\#include "etch_log.h" 

static const char* LOG_CATEGORY     = "$helper.getServiceName($intf)_helper";

static int ${i}_helper_resources_init(void* data)
{
    etch_server_factory* factory = (etch_server_factory*)data;
    int result = 0;
    ETCH_ASSERT((factory != NULL) && (factory->in_valufact == NULL));
    ETCH_ASSERT (factory->in_resx && is_etch_hashtable(factory->in_resx));

    // TODO use new semantic ${i}_valuefactory_create
    factory->in_valufact = (etch_value_factory*)new_${i}_valufact();
    ETCH_ASSERT(factory->in_valufact);
    if(factory->in_valufact == NULL) {
        return -1;
    }
    result = etch_resources_add(factory->in_resx, ETCH_RESXKEY_MSGIZER_VALUFACT, (etch_object*)factory->in_valufact);

    ETCH_ASSERT(0 == result);
    return result;
}

#if($helper.isClient($mc))
etch_status_t ${i}_helper_remote_server_create(${i}_remote_server** remote_server, wchar_t* uri, void* factory_thisx, main_client_create_func client_create)
{
    etch_status_t         rv                 = ETCH_SUCCESS;
    etch_client_factory*  factory            = NULL;
    ${i}_remote_server* newremote_server   = NULL;
    i_${i}_client*      client             = NULL;
    ${i}_client_stub*   client_stub        = NULL;
    ${i}_valufact*      vf                 = NULL;

    if(remote_server == NULL || client_create == NULL) {
        return ETCH_EINVAL;
    }

    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_INFO, "creating ${i} client ...\n");
    factory = new_client_factory (NULL, NULL, client_create);
    ETCH_ASSERT(factory != NULL);
	
	factory->thisx = factory_thisx;

    vf = new_${i}_valufact();
    ETCH_ASSERT(vf != NULL);

    factory->in_valufact = (etch_value_factory*)vf;
    factory->in_resx     = etch_transport_resources_init(factory->in_resx);
    ETCH_ASSERT(factory->in_resx != NULL);
    etch_resources_add (factory->in_resx, ETCH_RESXKEY_MSGIZER_VALUFACT, (etch_object*)vf);

    // instantiate a delivery service
    factory->dsvc = new_etch_transport(uri, (etch_factory_params*)factory, NULL);
    ETCH_ASSERT(is_etch_ideliverysvc(factory->dsvc));

    // instantiate the remote server
    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_DEBUG, "instantiating remote server ...\n");
    newremote_server = new_${i}_remote_server(NULL, factory->dsvc, (etch_value_factory*)vf);
    ETCH_ASSERT(is_etch_remote_server(newremote_server));

    factory->server_id = newremote_server->server_base->server_id;
    factory->server = newremote_server;
    newremote_server->client_factory = factory;

    /* here we call back to the client constructor in [main]. the purpose of the 
     * callback is to isolate the editable xxxx_client_impl constructor from the 
     * private constructor pieces. the callback instantiates a client implenentation
     * and returns an interface to it. 
     */   
    if(factory->new_client != NULL) {
        client = factory->new_client(factory, newremote_server);
        ETCH_ASSERT(is_etch_client_base(client));
        factory->iclient = client;
    }

    // get thread pools
    factory->fpool = (etch_threadpool*)etch_resources_get(factory->in_resx, ETCH_RESXKEY_POOLTYPE_FREE);
    ETCH_ASSERT(factory->fpool);
    factory->qpool = (etch_threadpool*)etch_resources_get(factory->in_resx, ETCH_RESXKEY_POOLTYPE_QUEUED);
    ETCH_ASSERT(factory->qpool);

    // construct client stub
    client_stub = new_${i}_client_stub(factory);
    ETCH_ASSERT(is_etch_client_stub(client_stub));
    factory->stub = client_stub;

    *remote_server = newremote_server;

    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_DEBUG,"remote server instantiated\n");
    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_INFO, "${i} client created\n");

    return rv;
}

etch_status_t ${i}_helper_remote_server_start_wait(${i}_remote_server* remote_server, const int waitms)
{
    etch_status_t   rv           = ETCH_SUCCESS;
    ${i}_remote*  remote       = NULL;
    int             result       = 0;

    if(remote_server == NULL) {
        return ETCH_EINVAL;
    }

    remote = remote_server->remote_base;
    ETCH_ASSERT(remote != NULL);

    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_INFO, "starting ${i} client ...\n");
    result = remote->start_waitup(remote, waitms);
    if(result != 0) {
        ETCH_LOG(LOG_CATEGORY, ETCH_LOG_ERROR, "could not start ${i} client\n");
        rv = ETCH_ERROR;
    } else {
        ETCH_LOG(LOG_CATEGORY, ETCH_LOG_INFO, "${i} client started\n");
        rv = ETCH_SUCCESS;
    }

    return rv;
}

etch_status_t ${i}_helper_remote_server_stop_wait(${i}_remote_server* remote_server, const int waitms)
{
    etch_status_t   rv         = ETCH_SUCCESS;
    ${i}_remote*  remote     = NULL;
    int             result     = 0;

    if(remote_server == NULL) {
        return ETCH_EINVAL;
    }

    remote = remote_server->remote_base;
    ETCH_ASSERT(remote != NULL);

    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_INFO, "stopping ${i} client ...\n");
    result = remote->stop_waitdown(remote, waitms);
    if(result != 0) {
        ETCH_LOG(LOG_CATEGORY, ETCH_LOG_ERROR, "could not stop ${i} client\n");
        rv = ETCH_ERROR;
    } else {
        ETCH_LOG(LOG_CATEGORY, ETCH_LOG_INFO, "${i} client stopped\n");
        rv = ETCH_SUCCESS;
    }

    return rv;
}

etch_status_t ${i}_helper_remote_server_destroy(${i}_remote_server* remote_server)
{
    etch_status_t rv     = ETCH_SUCCESS;

    if(remote_server == NULL) {
        return ETCH_EINVAL;
    }

    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_DEBUG, "destroying remote server ...\n");
    etch_object_destroy(remote_server);
    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_DEBUG, "remote server destroyed\n");

    return rv;
}

#end
#if($helper.isServer($mc))
static void* ${i}_helper_listener_create_func(void* factoryData, void* sessionData)
{
    etch_server_factory* factory = (etch_server_factory*)factoryData;
    etch_session* session = (etch_session*)sessionData;
    i_${i}_server* iserver;
    ${i}_server_stub* stub;
    ${i}_remote_client* client;
    ETCH_ASSERT(factory && factory->helper_new_listener && factory->main_new_server);
    ETCH_ASSERT(factory->in_resx && factory->in_valufact);   // TODO assert delivery service
    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_DEBUG, "instantiating accepted client listener ...\n");

    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_DEBUG, "creating remote client...\n");
    client = new_${i}_remote_client(NULL, session, factory->in_valufact);
    client->session_id = session->session_id;
    session->client = client;

    /* here we CALL BACK to the constructor in [main], the purpose of the callback
     * being to isolate the editable constructor from the private constructor. 
     * the callback instantiates a client's server implementation and returns 
     * an interface to it. 
     */ 
    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_DEBUG, "creating server implementation ...\n");
    iserver = factory->main_new_server(factory, session);
    iserver->session_id = session->session_id;
    session->server = iserver;

    /* note that the main listener will use p->mainpool as a thread manager, not these */
    factory->qpool = (etch_threadpool*)etch_resources_get(factory->in_resx, ETCH_RESXKEY_POOLTYPE_QUEUED);
    factory->fpool = (etch_threadpool*)etch_resources_get(factory->in_resx, ETCH_RESXKEY_POOLTYPE_FREE);

    /* eventually new_${i}_server_stub() gets to stub_base constructor, which sets
     * the delivery service's session to this, the server stub. so, in the java binding,
     * the server stub is referenced as delivery service.session. we should perhaps also 
     * store the stub opaquely in both the client and listener objects.
     */
    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_DEBUG, "creating server stub ...\n");
    stub = new_${i}_server_stub(factory, session);
    stub->session_id = session->session_id;
    session->server_stub = stub;

    if (iserver && stub)
        ETCH_LOG(LOG_CATEGORY, ETCH_LOG_DEBUG, "accepted client listener instantiated\n");
    else
        ETCH_LOG(LOG_CATEGORY, ETCH_LOG_ERROR, "could not instantiate accepted client listener\n");

    return stub;
}

etch_status_t ${i}_helper_listener_create(i_sessionlistener** listener, wchar_t* uri, void* factory_thisx, main_server_create_func server_create)
{
    etch_status_t       rv          = ETCH_SUCCESS;
    i_sessionlistener*  newlistener = NULL;

    if(listener == NULL || server_create == NULL) {
        return ETCH_EINVAL;
    }

    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_DEBUG, "instantiating main listener ...\n");

    newlistener = new_etch_listener(uri, NULL, factory_thisx, ${i}_helper_listener_create_func, server_create, ${i}_helper_resources_init);
    if(newlistener == NULL) {
        ETCH_LOG(LOG_CATEGORY, ETCH_LOG_ERROR, "could not instantiate main listener\n");
        rv = ETCH_ERROR;
    } else {
        ETCH_LOG(LOG_CATEGORY, ETCH_LOG_DEBUG, "main listener instantiated\n");
        *listener = newlistener;
        rv = ETCH_SUCCESS;
    }

    return rv;
}

etch_status_t ${i}_helper_listener_start_wait(i_sessionlistener* listener, const int waitms)
{
    etch_status_t rv     = ETCH_SUCCESS;
    int result           = 0;

    if(listener == NULL) {
        return ETCH_EINVAL;
    }

    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_INFO, "starting main listener ...\n");

    result = listener->transport_control(listener->thisx, new_etch_event(CLASSID_CONTROL_START_WAITUP, waitms), NULL);
    if(result != 0) {
        ETCH_LOG(LOG_CATEGORY, ETCH_LOG_ERROR, "could not start main listener\n");
        rv = ETCH_ERROR;
    } else {
        ETCH_LOG(LOG_CATEGORY, ETCH_LOG_INFO, "main listener started on thread %d\n", transport_thread_id(listener));
    }

    return rv;
}

etch_status_t ${i}_helper_listener_stop_wait(i_sessionlistener* listener, const int waitms)
{
    etch_status_t rv     = ETCH_SUCCESS;
    int result           = 0;

    if(listener == NULL) {
        return ETCH_EINVAL;
    }

    ETCH_LOG(LOG_CATEGORY, ETCH_LOG_INFO, "stopping main listener ...\n");

    result = listener->transport_control(listener->thisx, new_etch_event(CLASSID_CONTROL_STOP_WAITDOWN, waitms), NULL);
    if(result != 0) {
        ETCH_LOG(LOG_CATEGORY, ETCH_LOG_ERROR, "could not stop main listener\n");
        rv = ETCH_ERROR;
    } else {
        ETCH_LOG(LOG_CATEGORY, ETCH_LOG_INFO, "main listener ended\n");

        if (transport_session_count (listener) > 0) {
            ETCH_LOG(LOG_CATEGORY, ETCH_LOG_DEBUG, "begin client sessions teardown\n");
            result = transport_teardown_client_sessions(listener);
            ETCH_LOG(LOG_CATEGORY, ETCH_LOG_DEBUG, "end client sessions teardown\n");
        }
    }

    return rv;
}

etch_status_t ${i}_helper_listener_destroy(i_sessionlistener* listener)
{
    etch_status_t rv     = ETCH_SUCCESS;

    etch_object_destroy(listener);

    return rv;
}

#end //isSERVER
