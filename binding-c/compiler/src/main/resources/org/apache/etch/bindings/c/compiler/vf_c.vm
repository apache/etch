##
## Licensed to the Apache Software Foundation (ASF) under one
## or more contributor license agreements.  See the NOTICE file
## distributed with this work for additional information
## regarding copyright ownership.  The ASF licenses this file
## to you under the Apache License, Version 2.0 (the
## "License"); you may not use this file except in compliance
## with the License.  You may obtain a copy of the License at
##
##   http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing,
## software distributed under the License is distributed on an
## "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
## KIND, either express or implied.  See the License for the
## specific language governing permissions and limitations
## under the License.
##

// This file automatically generated by:
//   $version
//   $now
// This file is automatically created and should not be edited!

/*
 * $helper.getVfFileNameI($intf) 
 * $helper.getServiceName($intf) service value factory
 */
 
\#include "$helper.getVfFileNameH($intf)"
\#include "$helper.getIntfFileNameH($intf)"
\#include "etch_serializer.h"
\#include "etch_exception.h"
\#include "etch_objecttypes.h"
\#include "etch_general.h"
\#include "etch_map.h"
\#include "etch_runtime.h"
#foreach($serviceName in $helper.getUsedServiceNames($intf))	
\#include "${serviceName.toLowerCase()}_interface.h"
#end	
#foreach($serviceName in $helper.getUsedServiceNames($intf))	
\#include "${serviceName.toLowerCase()}_valufact.h"
#end

unsigned short CLASSID_$helper.getVfName($intf).toUpperCase()_IMPL;

static $helper.getVfName($intf)_statics* _g_$helper.getVfName($intf)_statics = NULL;

/* constructors */
etch_arraylist* $helper.getVfName($intf)_get_types($helper.getVfName($intf)*);

void $helper.getVfName($intf)_free_statics();

/* initializers */
static int $helper.getVfName($intf)_init_static_fields();
static int $helper.getVfName($intf)_init_static_types();
static int $helper.getVfName($intf)_init_static_parameters();
static int  $helper.getVfName($intf)_init_static_serializers();

#foreach($n in $intf.iterator())
#if ($n.isStruct() || $n.isEnumx() || $n.isExcept())
/* $n.name() serializer */
etch_serializer* new_$n.efqname($helper)_serializer(etch_type*, etch_field*); 
etch_object* etchserializer_$n.efqname($helper)_export_value(etch_serializer*, etch_object*);
etch_object* etchserializer_$n.efqname($helper)_import_value(etch_serializer*, etch_object*);
#end
#end

#set($valufactname = $helper.getVfName($intf))

/* - - - - - - - - - - - - - - - - - - - -
 * static constructors/destructors
 * - - - - - - - - - - - - - - - - - - - -
 */

etch_status_t $helper.getServiceName($intf)_etch_runtime_shutdown_hook_func()
{
    if(_g_$helper.getServiceName($intf)_valufact_statics) {
        $helper.getServiceName($intf)_valufact_free_statics();
    }
	return ETCH_SUCCESS;
}
 
${valufactname}_statics* ${valufactname}_get_static(){
    if(_g_${valufactname}_statics == NULL){
        _g_${valufactname}_statics  = malloc(sizeof(${valufactname}_statics));
        memset(_g_${valufactname}_statics ,0 ,sizeof(${valufactname}_statics)); 

        _g_${valufactname}_statics->_etch_${valufactname}_typemap = new_vf_types_collection(ETCH_DEFVF_IDNMAP_DEFINITSIZE);
        _g_${valufactname}_statics->_etch_${valufactname}_c2tmap = new_class_to_type_map(ETCH_DEVVF_C2TMAP_DEFINITSIZE);

        defvf_initialize_static(_g_${valufactname}_statics->_etch_${valufactname}_typemap, _g_${valufactname}_statics->_etch_${valufactname}_c2tmap);
        ${valufactname}_init_static_types();
        ${valufactname}_init_static_fields();
        ${valufactname}_init_static_parameters();
        ${valufactname}_init_static_serializers();
		etch_runtime_shutdown_hook_add($helper.getServiceName($intf)_etch_runtime_shutdown_hook_func);
    }

    return _g_${valufactname}_statics;
}


/**
 * $helper.getVfName($intf)_init_types()
 * instantiate type objects
 */
static int $helper.getVfName($intf)_init_static_types ()
{
    int restype = NULL;
    struct i_hashtable* vtab = NULL; 
	$helper.getVfName($intf)_statics* p =  $helper.getVfName($intf)_get_static();

    /* instantiate type name strings */
    
## generate messages
#foreach($n in $intf.iterator() )
#if($n.isMessage())
#if(!$n.isHidden())
	p->str_$helper.getServiceName($intf)_$n.name() = new_wchar(L"$intf.fqname().$n.name()");
#if(! $n.isOneway())
	p->str_$helper.getServiceName($intf)__result_$n.name() = new_wchar(L"$intf.fqname()._result_$n.name()");
#end
#end
#end
#end

#foreach($n in $intf.iterator() )
#if ($n.isStruct() || $n.isEnumx() || $n.isExcept())
    p->str_$n.efqname($helper) = new_wchar(L"$n.fqname()");
#end
#end

    /* instantiate type objects */
#foreach($n in $intf.iterator() )
#if($n.isMessage())
#if(!$n.isHidden())
    p->_mt_$helper.getServiceName($intf)_$n.name() = new_static_type(p->str_$helper.getServiceName($intf)_$n.name());
    ETCH_ASSERT(p->_mt_$helper.getServiceName($intf)_$n.name());
#if(! $n.isOneway())
    p->_mt_$helper.getServiceName($intf)__result_$n.name() = new_static_type(p->str_$helper.getServiceName($intf)__result_$n.name());
    ETCH_ASSERT(p->_mt_$helper.getServiceName($intf)__result_$n.name());
#end
#end
#end
#end

#foreach($n in $intf.iterator() )
#if ($n.isStruct() || $n.isEnumx() || $n.isExcept())
    p->_mt_$n.efqname($helper) = new_static_type(p->str_$n.efqname($helper));
    ETCH_ASSERT(p->_mt_$n.efqname($helper));
#end
#end
	vtab = (struct i_hashtable*)((etch_object*)p->_etch_$helper.getVfName($intf)_typemap)->vtab;
    /* add types to vf */
#foreach($n in $intf.iterator() )
#if($n.isMessage())
#if(!$n.isHidden())
   restype =  vtab->inserth(p->_etch_$helper.getVfName($intf)_typemap->realtable, p->_mt_$helper.getServiceName($intf)_$n.name(), NULL, p->_etch_$helper.getVfName($intf)_typemap, 0); 
   ETCH_ASSERT(! restype);
#if(! $n.isOneway())
   restype =  vtab->inserth(p->_etch_$helper.getVfName($intf)_typemap->realtable, p->_mt_$helper.getServiceName($intf)__result_$n.name(), NULL, p->_etch_$helper.getVfName($intf)_typemap, 0); 
   ETCH_ASSERT(! restype);
#end
#end
#end
#end

#foreach($n in $intf.iterator() )
#if ($n.isStruct() || $n.isEnumx() || $n.isExcept())
	restype =  vtab->inserth(p->_etch_$helper.getVfName($intf)_typemap->realtable, p->_mt_$n.efqname($helper), NULL, p->_etch_$helper.getVfName($intf)_typemap, 0); 
    ETCH_ASSERT(! restype);
#end
#end

    /* set type response fields */
#foreach($n in $intf.iterator() )
#if($n.isMessage())
#if(!$n.isHidden())
#if(!$n.isOneway())
    etchtype_set_response_field(p->_mt_$helper.getServiceName($intf)__result_$n.name(),  builtins._mf_result);
#end
#end
#end
#end

    /* set message result types */
#foreach($n in $intf.iterator() )
#if($n.isMessage())
#if(!$n.isHidden())
#if(!$n.isOneway())
    etchtype_set_result_type (p->_mt_$helper.getServiceName($intf)_$n.name(),  p->_mt_$helper.getServiceName($intf)__result_$n.name());
#end
#end
#end
#end

    /* set timeouts */
#foreach($n in $intf.iterator() )
#if($n.isMessage())
#if(!$n.isHidden())
#if(!$n.isOneway())
    etchtype_set_timeout (p->_mt_$helper.getServiceName($intf)__result_$n.name(),  $n.getTimeout());
#end
#end
#end
#end

	/* set async modes */
#foreach ( $n in $intf.iterator() )
#if ($n.isMessage())
#if (!$n.isHidden())
#if ($n.isQueuedAsyncReceiver())
    etchtype_set_async_mode(p->_mt_$helper.getServiceName($intf)_$n.name(), ETCH_ASYNCMODE_QUEUED);
#elseif ($n.isFreeAsyncReceiver())
    etchtype_set_async_mode(p->_mt_$helper.getServiceName($intf)_$n.name(), ETCH_ASYNCMODE_FREE);
#else
    etchtype_set_async_mode(p->_mt_$helper.getServiceName($intf)_$n.name(), ETCH_ASYNCMODE_NONE);
#end
#end
#end
#end

	return 0;
}


/**
 * $helper.getVfName($intf)_init_fields()
 * instantiate field objects
 */
static int $helper.getVfName($intf)_init_static_fields ()
{
#set ($tmp = $helper.resetHistory())
#foreach($n in $intf.iterator())
#if(!$n.isHidden())
#if(!$n.isBuiltin())
#foreach($p in $n.iterator())
#if(!$helper.historyContains($p.name().toString()))
    $helper.getVfName($intf)_get_static()->str_$helper.getServiceName($intf)_$p.name() = new_wchar(L"$p.name()");
#set ($tmp = $helper.addStringToHistory($p.name().toString()))
#end
#end
#end
#end
#end

#set ($tmp = $helper.resetHistory())
#foreach($n in $intf.iterator())
#if(!$n.isHidden())
#if(!$n.isBuiltin())
#foreach($p in $n.iterator())
#if(!$helper.historyContains($p.name().toString()))
    $helper.getVfName($intf)_get_static()->_mf_$helper.getServiceName($intf)_$p.name() = new_static_field($helper.getVfName($intf)_get_static()->str_$helper.getServiceName($intf)_$p.name());
#set ($tmp = $helper.addStringToHistory($p.name().toString()))
#end
#end
#end
#end
#end
	return 0;

}

/**
 * $helper.getVfName($intf)_init_parameters()
 * initialize service method parameters
 */
static int $helper.getVfName($intf)_init_static_parameters ()
{
	$helper.getVfName($intf)_statics* p = $helper.getVfName($intf)_get_static();
	
	
#foreach($n in $intf.iterator())
#if($n.isEnumx())
#foreach($p in $n.iterator())	
	etchtype_put_validator(p->_mt_$helper.getServiceName($intf)_$n.name(), 
		clone_field(p->_mf_$helper.getServiceName($intf)_$p.name()), (etch_object*)etchvtor_boolean_get(0));
#end		
#elseif($n.isStruct() || $n.isExcept())
//params for $n
#foreach( $p in $n.getAllParameters() )
	etchtype_put_validator(p->_mt_$helper.getServiceName($intf)_$n.name(),
	                       clone_field(p->_mf_$helper.getServiceName($intf)_$p.fqname()), 
		                   $helper.getValidator($intf, $p));
#end
#else
//params for $n
#foreach( $p in $n.iterator() )
#if($n.isHidden())
	etchtype_put_validator(p->_mt_$helper.getServiceName($intf)_$n.name(),
	                       builtins._mf_$p.fqname(), 
						   $helper.getValidator($intf, $p));
#else
	etchtype_put_validator(p->_mt_$helper.getServiceName($intf)_$n.name(),
	                       clone_field(p->_mf_$helper.getServiceName($intf)_$p.fqname()), 
						   $helper.getValidator($intf, $p));
#end						
#end		
#end
#if ($n.isMessage())
    etchtype_put_validator(p->_mt_$helper.getServiceName($intf)_$n.name(), 
        clone_field(builtins._mf__message_id), (etch_object*) etchvtor_int64_get(0));
#if ($n.isHidden())
	etchtype_put_validator(p->_mt_$helper.getServiceName($intf)_$n.name(), 
        clone_field(builtins._mf_result), (etch_object*) etchvtor_exception_get(0));
	etchtype_put_validator(p->_mt_$helper.getServiceName($intf)_$n.name(), 
        clone_field(builtins._mf__in_reply_to), (etch_object*) etchvtor_int64_get(0));
#set( $param = $n.getResultParam() )
#set( $reqMsg = $n.getRequestMessage() )
#foreach( $ex in $reqMsg.thrown().iterator() )
	etchtype_put_validator(p->_mt_$helper.getServiceName($intf)_$n.name(),
	                       builtins._mf_result, 
		                   $helper.getValidator($intf, $ex));
#end
	etchtype_put_validator(p->_mt_$helper.getServiceName($intf)_$n.name(),
	                       builtins._mf_result, 
		                   $helper.getValidator($intf, $param));
#end
#end	
#end

	return 0;
}

/**
 * $helper.getVfName($intf)_init_serializers()
 */
static int $helper.getVfName($intf)_init_static_serializers ()
{
    int  result = 0;
#foreach($n in $intf.iterator())
#if ($n.isExcept())
#set( $c2map_needed = true )
#elseif ($n.isStruct()  || $n.isEnumx())
#set( $c2map_needed = true )
#end
#end
#if ($c2map_needed)
    $helper.getVfName($intf)_statics* p = $helper.getVfName($intf)_get_static();
    class_to_type_map* c2tmap = p->_etch_$helper.getVfName($intf)_c2tmap;
#end

#foreach($n in $intf.iterator() )
#if ($n.isStruct() || $n.isEnumx() || $n.isExcept())
    const unsigned short classid_$n.efqname($helper) = get_dynamic_classid_unique(&CLASSID_$n.efqname($helper).toUpperCase());
#end
#end 

    /* note that etch_serializer_init takes care of the class to type, setting
     * of component type, instantiation of import export helper and installing
     * it to the type. 
     */

#foreach($n in $intf.iterator() )
#if($n.isExcept())
	  /* serializer for $n.efqname($helper) */
    result = etch_serializer_init (p->_mt_$n.efqname($helper), p->str_$n.efqname($helper), 
        ETCHMAKECLASS(ETCHTYPEB_EXCEPTION, classid_$n.efqname($helper)), 
            c2tmap, NULL, new_$n.efqname($helper)_serializer);

#elseif ($n.isStruct()  || $n.isEnumx())
    /* serializer for $n.efqname($helper) */
    result = etch_serializer_init (p->_mt_$n.efqname($helper), p->str_$n.efqname($helper), 
        ETCHMAKECLASS(ETCHTYPEB_USER, classid_$n.efqname($helper)), 
            c2tmap, NULL, new_$n.efqname($helper)_serializer);

#end
#end
    return result;
}



/**
 * destroy_$helper.getVfName($intf)_impl()
 * destructor for the $helper.getServiceName($intf) value factory extension
 */
int destroy_$helper.getVfName($intf)_impl(void* data)
{
    $helper.getVfName($intf)_impl* impl = ($helper.getVfName($intf)_impl*)data;
    if (NULL == impl) return -1;

    if (!is_etchobj_static_content(impl))
    {
        // add if neccessary
    }

   return destroy_objectex((etch_object*) impl);
}


/* - - - - - - - - - - - - - - - - - - - -
 * constructors/destructors
 * - - - - - - - - - - - - - - - - - - - -
 */
 
$helper.getVfName($intf)* new_$helper.getVfName($intf)()
{
    $helper.getVfName($intf)_impl* impl = NULL;
	default_value_factory* pvf = new_default_value_factory (
		$helper.getVfName($intf)_get_static()->_etch_$helper.getVfName($intf)_typemap, 
		$helper.getVfName($intf)_get_static()->_etch_$helper.getVfName($intf)_c2tmap);
    ETCH_ASSERT(pvf);

    /* note that the vf destructor is the default value factory destructor,
     * which in turn invokes the destructor on its impl object 
     */
    impl = ($helper.getVfName($intf)_impl*) new_object (sizeof($helper.getVfName($intf)_impl), 
       ETCHTYPEB_VALUEFACTIMP, get_dynamic_classid_unique(&CLASSID_$helper.getVfName($intf).toUpperCase()_IMPL));

    ((etch_object*)impl)->destroy = destroy_$helper.getVfName($intf)_impl; 
    pvf->impl = (etch_object*) impl;	
#foreach ( $n in $intf.iterator() )
#if ($n.isMixin())
#set( $m = $n.getModule() )
#set( $s = $m.iterator().next() )
	defvf_add_mixin(pvf, (etch_value_factory*)new_$s.name().toString().toLowerCase()_valufact());
#end
#end
    return pvf; 
}


/* - - - - - - - - - - - - - - - - - - - -
 * vf class methods
 * - - - - - - - - - - - - - - - - - - - -
 */
 
void $helper.getVfName($intf)_free_statics ()
{
    
	$helper.getVfName($intf)_statics* data = $helper.getVfName($intf)_get_static();
    ETCH_ASSERT(data); 

#foreach($n in $intf.iterator() )
#if($n.isMessage())
#if(!$n.isHidden())
    destroy_static_type (data->_mt_$helper.getServiceName($intf)_$n.name());
#if(! $n.isOneway())	
    destroy_static_type (data->_mt_$helper.getServiceName($intf)__result_$n.name());
#end	
#end
#end
#end
	
#foreach($n in $intf.iterator() )
#if ($n.isStruct() || $n.isExcept()  || $n.isEnumx())
    destroy_static_type (data->_mt_$n.efqname($helper));
#end
#end

#set ($tmp = $helper.resetHistory())
#foreach($n in $intf.iterator())
#if (!$n.isHidden())
#foreach($p in $n.iterator())
#if(!$helper.historyContains($p.name().toString()))
    destroy_static_field(data->_mf_$helper.getServiceName($intf)_$p.name());
#set ($tmp = $helper.addStringToHistory($p.name().toString()))
#end
#end
##
#end
#end

#set ($tmp = $helper.resetHistory())
#foreach($n in $intf.iterator())
#if (!$n.isHidden())
#foreach($p in $n.iterator())
#if(!$helper.historyContains($p.name().toString()))
    etch_free (data->str_$helper.getServiceName($intf)_$p.name());
#set ($tmp = $helper.addStringToHistory($p.name().toString()))
#end
#end
##
#end
#end

#foreach($n in $intf.iterator())
#if($n.isMessage())
#if(!$n.isHidden())
    etch_free (data->str_$helper.getServiceName($intf)_$n.name());
#if(! $n.isOneway())  	
    etch_free (data->str_$helper.getServiceName($intf)__result_$n.name());
#end
##
#end
#end
#end

#foreach($n in $intf.iterator() )
#if ($n.isStruct() || $n.isExcept() || $n.isEnumx())
    etch_free (data->str_$n.efqname($helper));
#end
#end


    //set_etchobj_static_content(data->_etch_$helper.getServiceName($intf)_valufact_typemap);
    //set_etchobj_static_content(data->_etch_$helper.getServiceName($intf)_valufact_c2tmap);
	
	data->_etch_$helper.getServiceName($intf)_valufact_typemap->is_readonly_keys = 0;
    data->_etch_$helper.getServiceName($intf)_valufact_c2tmap->is_readonly_keys = 0;
    etch_object_destroy(data->_etch_$helper.getServiceName($intf)_valufact_typemap);
    etch_object_destroy(data->_etch_$helper.getServiceName($intf)_valufact_c2tmap);

	etch_free(data);
	_g_$helper.getServiceName($intf)_valufact_statics = NULL;
}


/* - - - - - - - - - - - - - - - - - - - -
 * serializers
 * - - - - - - - - - - - - - - - - - - - -
 */
 
#foreach($n in $intf.iterator() )
#if ($n.isStruct() || $n.isEnumx() || $n.isExcept())
/**
 * etchserializer_$n.efqname($helper)_export_value() 
 * export valueof a $n.efqname($helper)
 * @param objval a $n.efqname($helper), caller owns it and presumably will
 * destroy it upon return from this method.
 * @return the exported disposable structvalue object. caller must cast it.
 */
etch_object* etchserializer_$n.efqname($helper)_export_value(etch_serializer* thisx, etch_object* objval)
{
    const int THISINITSIZE = 2;
    etch_structvalue* expstruct = NULL;
    const unsigned short classid_$n.efqname($helper) = get_dynamic_classid_unique(&CLASSID_$n.efqname($helper).toUpperCase());
#if($n.isExcept())
	if (!is_etch_objparams(objval, ETCHTYPEB_EXCEPTION, classid_$n.efqname($helper))) return NULL;
#else
	if (!is_etch_objparams(objval, ETCHTYPEB_USER, classid_$n.efqname($helper))) return NULL;
#end

    expstruct = new_structvalue((etch_type*) thisx->type, THISINITSIZE);

#if($n.isEnumx())	
	switch((($n.efqname($helper)*)objval)->value)
	{
#foreach($enumType in $n.iterator())
       case $n.name()_$enumType: structvalue_put(expstruct, clone_field(_g_$helper.getVfName($intf)_statics->_mf_$helper.getServiceName($intf)_$enumType), (etch_object*) new_boolean(TRUE)); break;
#end
    }
#end

#foreach($p in $n.getAllParameters())
#if($p.type().isArray())
	structvalue_put(expstruct, _g_$helper.getVfName($intf)_statics->_mf_$helper.getServiceName($intf)_$p.name(), 
       etch_object_clone_func((void*)(($n.efqname($helper)*)objval)->${p.fqname()}));
#elseif($helper.isEnumParam($p))
	structvalue_put(expstruct, _g_$helper.getVfName($intf)_statics->_mf_$helper.getServiceName($intf)_$p.name(), 
       (etch_object*)new_$helper.getIntfName( $intf )_$p.type()_init((($n.efqname($helper)*)objval)->${p.fqname()}));
#elseif($helper.getValidatorStringForParam($p) == 'object'
		|| $helper.getValidatorStringForParam($p) == 'string')
	if((($n.efqname($helper)*)objval)->${p.fqname()}) {
		structvalue_put(expstruct, _g_$helper.getVfName($intf)_statics->_mf_$helper.getServiceName($intf)_$p.name(), 
			etch_object_clone_func((void*)(($n.efqname($helper)*)objval)->${p.fqname()}));
	}
#else
    structvalue_put(expstruct, _g_$helper.getVfName($intf)_statics->_mf_$helper.getServiceName($intf)_$p.name(),
	   (etch_object*) new_$helper.getValidatorStringForParam($p)((($n.efqname($helper)*)objval)->$p.fqname()));
#end	      
#end
    return (etch_object*) expstruct; /* caller owns this structvalue */
}

/**
 * etchserializer_$n.efqname($helper)_import_value() 
 * import value for a $n.efqname($helper).
 * @param objval an etch_structvalue of appropriate type for the $n.efqname($helper).
 * caller retains ownership of this object as with all imports.
 * @return an opaque etch object containing the imported $n.efqname($helper). 
 * caller owns and must destroy the returned object.  
 */
etch_object* etchserializer_$n.efqname($helper)_import_value (etch_serializer* thisx, etch_object* objval) 
{
    $n.efqname($helper)* outobj = NULL;
	
#foreach($p in $n.getAllParameters())
    $helper.getEtchTypeName($p.type())* valobj_$p.name() = NULL;
#end	   

#if($n.isEnumx())
	$helper.getIntfName( $intf )_$n.name()_enum enumValue = NULL;
	etch_boolean* enumFlagValue;
#end

    etch_structvalue* instruct = NULL;
    if (!is_etch_struct(objval)) return NULL;

    instruct = (etch_structvalue*) objval;
    if (!structvalue_is_type(instruct, thisx->type)) return NULL;

#if($n.isEnumx())

#foreach($enumType in $n.iterator())
    enumFlagValue = (etch_boolean*) structvalue_get(instruct, _g_$helper.getVfName($intf)_statics->_mf_$helper.getServiceName($intf)_$enumType);
    if(enumFlagValue && enumFlagValue->value)
    {
        enumValue = $n.name()_$enumType;
    }
#end	

#end

#foreach($p in $n.getAllParameters())
    /* fetch the $p.name() value wrapper out of the struct. struct owns it */
#if($helper.isEnumParam($p))
	valobj_$p.name() = ($helper.getEtchTypeName($p.type())*) structvalue_get(instruct, _g_$helper.getVfName($intf)_statics->_mf_$helper.getServiceName($intf)_$p.name());
#elseif($p.type().isArray())
    valobj_$p.name() = (etch_arraytype*) structvalue_remove(instruct, _g_$helper.getVfName($intf)_statics->_mf_$helper.getServiceName($intf)_$p.name());	
#elseif($helper.getValidatorStringForParam($p) == 'object')
    valobj_$p.name() = ($helper.getEtchTypeName($p.type())*) structvalue_get(instruct, _g_$helper.getVfName($intf)_statics->_mf_$helper.getServiceName($intf)_$p.name());
#else
    valobj_$p.name() = ($helper.getEtchTypeName($p.type())*) structvalue_get(instruct, _g_$helper.getVfName($intf)_statics->_mf_$helper.getServiceName($intf)_$p.name());
#end	
#if($p.type().isArray())
    if (valobj_$p.name() && !is_etch_arraytype(valobj_$p.name())) return NULL;
#elseif($p.type().isObject())
	//nothing to check, is object
#else
    if (valobj_$p.name() && !is_$helper.getEtchTypeName($p.type())(valobj_$p.name())) return NULL;
#end
#end

    outobj = new_$n.efqname($helper)();
	
#if($n.isEnumx())
    outobj->value = enumValue;
#end
	
#foreach($p in $n.getAllParameters())
#if($p.type().isArray())
    if(valobj_$p.name())
    outobj->$p.name() = valobj_$p.name(); 
    //outobj->$p.name() = (etch_arraytype*) etch_object_clone_func((void*)valobj_$p.name());	
#elseif($helper.getValidatorStringForParam($p) == 'string')	
    if(valobj_$p.name())
        outobj->$p.name() = (etch_string*) etch_object_clone_func((void*)valobj_$p.name());
#elseif($helper.isEnumParam($p))
    if(valobj_$p.name())
        outobj->$p.name() = valobj_$p.name()->value;
#elseif($helper.getValidatorStringForParam($p) == 'object')
    if(valobj_$p.name())
        outobj->$p.name() = ($helper.getEtchTypeName($p.type())*) etch_object_clone_func((void*)valobj_$p.name());
#else
    if(valobj_$p.name())
        outobj->$p.name() = valobj_$p.name()->value;
#end
#end
    return (etch_object*) outobj;  /* caller owns this object */
}

/**
 * new_$n.efqname($helper)_serializer() 
 * etch_serializer_excp constructor - conforms to typedef etch_serializer_ctor
 * @param type  - not owned
 * @param field - not owned
 */
etch_serializer* new_$n.efqname($helper)_serializer(etch_type* type, etch_field* field) 
{
    etch_serializer* newobj = new_etch_serializer(ETCH_DEFSIZE);

    ((etch_object*)newobj)->class_id = get_dynamic_classid_unique(&CLASSID_$n.efqname($helper).toUpperCase()_SERIALIZER);
    newobj->type  = type;  /* not owned */
    newobj->field = field; /* not owned */

    newobj->export_value = etchserializer_$n.efqname($helper)_export_value;
    newobj->import_value = etchserializer_$n.efqname($helper)_import_value;

    return newobj;
}

#end
#end
