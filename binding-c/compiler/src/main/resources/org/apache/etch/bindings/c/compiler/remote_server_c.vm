##
## Licensed to the Apache Software Foundation (ASF) under one
## or more contributor license agreements.  See the NOTICE file
## distributed with this work for additional information
## regarding copyright ownership.  The ASF licenses this file
## to you under the Apache License, Version 2.0 (the
## "License"); you may not use this file except in compliance
## with the License.  You may obtain a copy of the License at
##
##   http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing,
## software distributed under the License is distributed on an
## "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
## KIND, either express or implied.  See the License for the
## specific language governing permissions and limitations
## under the License.
##

// This file automatically generated by:
//   $version
//   $now
// This file is automatically created and should not be edited!

/*
 * $helper.getRemoteFileNameI($intf, $suffix)
 * generated remote procedure calls.
 */

\#include "$helper.getRemoteFileNameH($intf, $suffix)"
#foreach( $x in $intf.iterator() )
#if( $x.isMixin() )
#set( $m = $x.getModule() )
#foreach( $z in $m.iterator() )
\#include "$helper.getRemoteFileNameH($z, $suffix)"
#end
#end
#end
\#include "etch_plain_mailbox_manager.h"
\#include "etch_svcobj_masks.h"
\#include "etch_objecttypes.h"
\#include "etch_exception.h"
\#include "etch_url.h" 
\#include "etch_log.h" 
\#include "etch_general.h"

unsigned short CLASSID_$helper.getRemoteName($intf, $suffix).toUpperCase();	
	
char* $helper.getServiceName($intf).toUpperCase()_ETCHREMS = "REMS";

## generate async begin typedefs
#foreach( $n in $intf.iterator() )
#if ($n.isMessage())
#if (!$n.isHidden())
#if ($n.isMsgDir($mc) || $n.isMsgDirBoth())	
	
#set ($sb = "$helper.getPointerTypeName($n.type()) $helper.getRemoteName($intf, '')_server_$n.name() (void* thisAsVoid")
#foreach( $p in $n.iterator() )
#set ( $sb = "$sb, $helper.getTypeName($p.type()) $p.name()")
#end
#set ($sb = "$sb);")
$sb
#if (!$n.isOneway())
#set ($sb = "i_mailbox* $helper.getRemoteName($intf, '')_begin_server_$n.name() (void* thisAsVoid")
#foreach( $p in $n.iterator() )
#set ( $sb = "$sb, $helper.getTypeName($p.type()) $p.name()")
#end
#set ($sb = "$sb);")
$sb
#set ($sb = "$helper.getPointerTypeName($n.type()) $helper.getRemoteName($intf, '')_end_server_$n.name()(void*, i_mailbox*);")
$sb
#end

#end
#end
#end
#end

int destroy_$helper.getRemoteName($intf, $suffix) (void*);

/* - - - - - - - - - -   
 * instantiation etc.
 * - - - - - - - - - -  
 */

/**
 * new_$helper.getRemoteName($intf, $suffix)()
 * $helper.getRemoteName($intf, $suffix) constructor.
 * @param thisx owner, optional, null in practice.
 * @param ids delivery service interface, caller retains.
 * @param vf service specific value factory, caller retains.
 */
$helper.getRemoteName($intf, $suffix)* new_$helper.getRemoteName($intf, $suffix) (void* thisx, i_delivery_service* ids, etch_value_factory* vf)
{
    $helper.getRemoteName($intf, $suffix)* rs = ($helper.getRemoteName($intf, $suffix)*) new_object (sizeof($helper.getRemoteName($intf, $suffix)), 
        ETCHTYPEB_REMOTESERVER, get_dynamic_classid_unique(&CLASSID_$helper.getRemoteName($intf, $suffix).toUpperCase()));

    ((etch_object*)rs)->destroy = destroy_$helper.getRemoteName($intf, $suffix);

    rs->remote_base = new_$helper.getRemoteName($intf, "") (thisx, ids, vf, NULL);
    rs->remote_base->remote_type = ETCH_REMOTETYPE_SERVER;

    /* 2/3/09 now passing perf interface not owned by server_base */
    rs->server_base = new_$helper.getRemoteName($intf, $suffix)_base (thisx, rs->remote_base->i$helper.getIntfName($intf));  

    rs->vf = ($helper.getVfName($intf)*) rs->remote_base->vf;

#foreach( $n in $intf.iterator() )
#if ($n.isMessage())
#if (!$n.isHidden())
#if ($n.isMsgDir($mc) || $n.isMsgDirBoth())	
    rs->$n.name() = $helper.getRemoteName($intf, '')_server_$n.name();
#if (!$n.isOneway())
    rs->async_begin_$n.name() = $helper.getRemoteName($intf, '')_begin_server_$n.name();
    rs->async_end_$n.name() = $helper.getRemoteName($intf, '')_end_server_$n.name();
#end	
#end
#end
#end
#end

#foreach( $x in $intf.iterator() )
#if( $x.isMixin() )
#set( $m = $x.getModule() )
#foreach( $z in $m.iterator() )
#foreach( $n in $z.messages( true ) )
#if (!$n.isHidden())
#if ($n.isMsgDir($mc) || $n.isMsgDirBoth())
    rs->$n.name() = $helper.getRemoteName($z, '')_server_$n.name();
#if (!$n.isOneway())
    rs->async_begin_$n.name() = $helper.getRemoteName($z, '')_begin_server_$n.name();
    rs->async_end_$n.name() = $helper.getRemoteName($z, '')_end_server_$n.name();
#end
#end
#end	
#end
#end
#end
#end

    return rs;
}

/**
 * destroy_$helper.getBaseName($intf, $suffix)_base()
 * i_$helper.getBaseName($intf, $suffix) destructor.
 */
int destroy_$helper.getRemoteName($intf, $suffix) (void* thisAsVoid)
{
    $helper.getRemoteName($intf, $suffix)* thisx = ($helper.getRemoteName($intf, $suffix)*)thisAsVoid;
    if (NULL == thisx) return -1;

    if (!is_etchobj_static_content(thisx))
    {
        etch_object_destroy(thisx->remote_base);
		thisx->remote_base = NULL;
		etch_object_destroy(thisx->server_base);
		thisx->server_base = NULL;
		etch_object_destroy(thisx->client_factory);
		thisx->client_factory = NULL;
    }

    return destroy_objectex((etch_object*)thisx);
}


/**
 * perf_remote_dispose_mailbox()
 * dispose of mailbox after use.
 * this is the common means of disposing of a mailbox when we're done with it.
 * this would intuitively be part of base class code but we don't have one.
 * @param thisx the remote server this.
 * @param pibox pointer to pointer to the mailbox interface, passed indirectly
 * such that this method can null out the caller's mailbox reference.
 * @return 0 if mailbox was successfullly closed, otherwise -1. 
 * caller's i_mailbox reference is nulled out regardless of result.
 */
int $helper.getRemoteName($intf, "")_${suffix}_dispose_mailbox ($helper.getRemoteName($intf, $suffix)* thisx, i_mailbox** pibox)
{
    int result = 0;
    i_mailbox* ibox = 0;
    if (!pibox || !*pibox) return -1;
    ibox = *pibox;
    *pibox = NULL;  /* null out caller's reference */
    
    if (0 != (result = ibox->close_read (ibox)))
    {  
        /* we should not need this failsafe unregister if close_read() 
         * is reliable, since close_read() will do the unregister */
        i_mailbox_manager* imgr = ibox->manager(ibox);
        ETCH_LOG($helper.getServiceName($intf).toUpperCase()_ETCHREMS, ETCH_LOG_ERROR, "could not close mailbox %x\n", ibox);
        if (imgr) result = imgr->unregister(imgr, ibox);
    }
 
    /* mailbox manager does not destroy the unregistered mailbox since it is    
     * owned by whoever registered it, that being us, so we destroy it here. 
     * debug heap issue note: this is/was the spot.
     */
    etch_object_destroy(ibox);   
    return result;
}

etch_stub* $helper.getRemoteName($intf, "")_${suffix}_get_stubbase ($helper.getRemoteName($intf, $suffix)* thisx)
{
    etch_stub* stub = NULL;
    xxxx_either_stub* clistub = (xxxx_either_stub*) thisx->client_factory->stub;
    stub = clistub? clistub->stub_base: NULL;
    return stub;
}


/**
 * $helper.getRemoteName($intf, "")_set_session_notify()
 * convenience to override remote server's session_notify().
 * @return the session_notify function that was overridden.
 */
etch_session_notify $helper.getRemoteName($intf, "")_${suffix}_set_session_notify($helper.getRemoteName($intf, $suffix)* thisx, etch_session_notify newfunc)
{
    etch_session_notify oldfunc = NULL;
    etch_stub* stub = $helper.getRemoteName($intf, "")_${suffix}_get_stubbase(thisx);
    if (NULL == stub || NULL == stub->impl_callbacks) return NULL;
    oldfunc = stub->impl_callbacks->_session_notify;
    stub->impl_callbacks->_session_notify = newfunc;
    return oldfunc;
}


/**
 * $helper.getRemoteName($intf, "")_set_session_control()
 * convenience to override remote server's session_control().
 * @return the session_control function that was overridden.
 */
etch_session_control $helper.getRemoteName($intf, "")_${suffix}_set_session_control($helper.getRemoteName($intf, $suffix)* thisx, etch_session_control newfunc)
{
    etch_session_control oldfunc = NULL;
    etch_stub* stub = $helper.getRemoteName($intf, "")_${suffix}_get_stubbase(thisx);
    if (NULL == stub || NULL == stub->impl_callbacks) return NULL;
    oldfunc = stub->impl_callbacks->_session_control;
    stub->impl_callbacks->_session_control = newfunc;
    return oldfunc;
}


/**
 * $helper.getRemoteName($intf, "")_set_session_query()
 * convenience to override remote server's session_query().
 * @return the session_query function that was overridden.
 */
etch_session_query $helper.getRemoteName($intf, "")_${suffix}_set_session_query($helper.getRemoteName($intf, $suffix)* thisx, etch_session_query newfunc)
{
    etch_session_query oldfunc = NULL;
    etch_stub* stub = $helper.getRemoteName($intf, "")_${suffix}_get_stubbase(thisx);
    if (NULL == stub || NULL == stub->impl_callbacks) return NULL;
    oldfunc = stub->impl_callbacks->_session_query;
    stub->impl_callbacks->_session_query = newfunc;
    return oldfunc;
}


/* - - - - - - - - - - - - - - - - - - - -  
 * remote procedure call implementations
 * - - - - - - - - - - - - - - - - - - - - 
 */
 
#foreach( $n in $intf.iterator() )
#if ($n.isMessage())
#if (!$n.isHidden())
#if ($n.isMsgDir($mc) || $n.isMsgDirBoth())
	
/* - - - - - - - - - - -  
 * $helper.getIntfName($intf).$n.name()()
 * - - - - - - - - - - -  
 */
 
#if (!$n.isOneway())
/**
 * $helper.getRemoteName($intf, '')_begin_$n.name()()
 * $helper.getIntfName($intf).$n.name() async start 
 * TODO: doc generation
 */
#set ($sb = "i_mailbox* $helper.getRemoteName($intf, '')_begin_server_$n.name()(void* thisAsVoid")
#foreach( $p in $n.iterator() )
#set ( $sb = "$sb, $helper.getTypeName($p.type()) $p.name()")
#end
#set ($sb = "$sb)")
$sb
{
    $helper.getRemoteName($intf, $suffix)* thisx = ($helper.getRemoteName($intf, $suffix)*)thisAsVoid;
    int _result = 0;
    i_mailbox* _mbox = NULL;
    etch_message* _msg = NULL;
    etch_type* _msgtype = $helper.getVfName($intf)_get_static()->_mt_$helper.getServiceName($intf)_$n.name();

    do
    {   
        _msg = thisx->remote_base->new_message (thisx->remote_base, _msgtype);
        if (!_msg) break;

#foreach( $p in $n.iterator() )
        _result = etch_message_putc (_msg, $helper.getVfName($intf)_get_static()->_mf_$helper.getIntfName($intf)_$p.name(), (void**)&$p.name());
		if ($p.name() != NULL && 0 != _result) break; 
#end

        /* fyi msg memory is relinquished here regardless of result */ 
        _result = thisx->remote_base->begin_call(thisx->remote_base, _msg, (void**)&_mbox);
        _msg = NULL;

    } while(0);

    /* destroy any unrelinquished objects */
#foreach( $p in $n.iterator() )
    etch_object_destroy($p.name());
	$p.name() = NULL;
#end
    etch_object_destroy(_msg);
	_msg = NULL;
	
    return _mbox;
}

/**
 * $helper.getRemoteName($intf, "")_end__$n.name()()
 * _$n.name() async end (read result from mailbox and return result)
 * @param thisx this.
 * @param mbox caller relinquishes
 * @return etch_int32* result of add, caller owns.
 */
$helper.getPointerTypeName($n.type()) $helper.getRemoteName($intf, "")_end_server_$n.name() (void* thisAsVoid, i_mailbox* ibox)
{
    $helper.getRemoteName($intf, $suffix)* thisx = ($helper.getRemoteName($intf, $suffix)*)thisAsVoid;
    $helper.getPointerTypeName($n.type()) _resobj = NULL;
    int _result = -1;
    etch_type* _restype = $helper.getVfName($intf)_get_static()->_mt_$helper.getServiceName($intf)__result_$n.name();
    
    if(ibox == NULL) {
        return NULL;
    }

    thisx->remote_base->end_call(thisx->remote_base, ibox, _restype, (void**)&_resobj);
    
    _result = $helper.getRemoteName($intf, '')_${suffix}_dispose_mailbox (thisx, &ibox);
    if(_result) {
     	etch_exception* excp = new_etch_exception_from_errorcode(ETCH_ERROR);
        etch_exception_set_message(excp,new_stringw(L"can not dispose mailbox."));
        return ($helper.getPointerTypeName($n.type()))excp;
    }
    
    return _resobj;
}

/**
 * $helper.getRemoteName($intf, "")_$n.name()
 * $helper.getIntfName($intf).$n.name() remote method call.
 * instantiates a mailbox, sends perf.add message, waits for result to arrive
 * in mailbox, disposes mailbox, and returns object containing add() result.
 * @param thisx this.
 * @param x etch_int32* caller relinquishes.
 * @param y etch_int32* caller relinquishes.
 * @return etch_int32* result of add, caller owns.
 */
#set ($sb = "$helper.getPointerTypeName($n.type()) $helper.getRemoteName($intf, '')_server_$n.name()(void* thisAsVoid")
#foreach( $p in $n.iterator() )
#set ( $sb = "$sb, $helper.getTypeName($p.type()) $p.name()")
#end
#set ($sb = "$sb)")
$sb
{
    $helper.getRemoteName($intf, $suffix)* thisx = ($helper.getRemoteName($intf, $suffix)*)thisAsVoid;
    $helper.getPointerTypeName($n.type()) _resultobj = NULL;

#set ($sb = "i_mailbox* _mbox = $helper.getRemoteName($intf, '')_begin_server_$n.name()(thisx")
#foreach( $p in $n.iterator() )
#set ( $sb = "$sb, $p.name()")
#end
#set ($sb = "$sb);")
    $sb

	if(_mbox == NULL){
		etch_exception* excp = new_etch_exception_from_errorcode(ETCH_EIO);
        etch_exception_set_message(excp,new_stringw(L"can not create mailbox, connection could be down."));
        return ($helper.getPointerTypeName($n.type()))excp;
	}

    _resultobj = $helper.getRemoteName($intf, "")_end_server_$n.name() (thisx, _mbox);

    return _resultobj;
}

## generate oneway
#else
/**
 * $helper.getRemoteName($intf, '')_begin_$n.name()()
 * $helper.getIntfName($intf).$n.name() async start 
 * @param thisx this.
 * @param x etch_int32* caller relinquishes.
 * @param y etch_int32* caller relinquishes.
 * @return mailbox to receive async result. caller owns it. it may be null.
 * @remarks note that we use the putc version of message.put(), wherein we pass
 * a *reference* to the value object's pointer, and message.putc() nulls out  
 * the reference. this permits us to break when a putc() error occurs, without  
 * leaking the un-put parameters, since prior to exit we can destroy each 
 * parameter which remains non-null.
 * @remarks note also that we don't bother to clone the value keys, since they  
 * are protected objects, and while etch_message_put will appear to destroy them,
 * this will have no effect.
 */
#set ($sb = "$helper.getPointerTypeName($n.type()) $helper.getRemoteName($intf, '')_begin_server_$n.name()(void* thisAsVoid")
#foreach( $p in $n.iterator() )
#set ( $sb = "$sb, $helper.getTypeName($p.type()) $p.name()")
#end
#set ($sb = "$sb)")
$sb
{
    $helper.getRemoteName($intf, $suffix)* thisx = ($helper.getRemoteName($intf, $suffix)*)thisAsVoid;
#foreach( $p in $n.iterator() )
#set($result_needed = true)
#end
#if($result_needed)
    int _result = 0;
#end
    etch_message* _msg = NULL;
    $helper.getPointerTypeName($n.type()) _resultobj = NULL;
    etch_type* _msgtype = $helper.getVfName($intf)_get_static()->_mt_$helper.getServiceName($intf)_$n.name();

    do
    {   
        _msg = thisx->remote_base->new_message (thisx->remote_base, _msgtype);
        if (!_msg) break;

#foreach( $p in $n.iterator() )
        _result = etch_message_putc (_msg, $helper.getVfName($intf)_get_static()->_mf_$helper.getIntfName($intf)_$p.name(), (void**)&$p.name());
        if ($p.name() != NULL && 0 != _result) break;
#end

        /* fyi msg memory is relinquished here regardless of result */ 
        /* fyi msg memory is relinquished here regardless of result */ 
        _resultobj = thisx->remote_base->sendex (thisx->remote_base, _msg);
        _msg = NULL;

    } while(0);

    /* destroy any unrelinquished objects */
#foreach( $p in $n.iterator() )
    etch_object_destroy($p.name());
	$p.name() = NULL;
#end
    etch_object_destroy(_msg);
	_msg = NULL;	
    return _resultobj;
}

/**
 * $helper.getRemoteName($intf, '')_end_$n.name()()
 * async result handler not used since $helper.getIntfName($intf).$n.name() is a one-way send-and-forget method.
 */
void* $helper.getRemoteName($intf, '')_end_server_$n.name() (void* thisAsVoid, i_mailbox* mbox)
{
    return NULL;
}

/**
 * $helper.getRemoteName($intf, '')_$n.name()()
 * $helper.getIntfName($intf).$n.name() remote 1-way method call.
 * sends $helper.getIntfName($intf).$n.name() message and does not wait for a result. if server implementation
 * code throws an exception, the exception arrives via session_notify override if any.
 * @param code an integer object, caller relinquishes.
 * @param x etch_string caller relinquishes.
 * @return integer transport result code cast to void*.
 */
#set ($sb = "$helper.getPointerTypeName($n.type()) $helper.getRemoteName($intf, '')_server_$n.name()(void* thisAsVoid")
#foreach( $p in $n.iterator() )
#set ( $sb = "$sb, $helper.getTypeName($p.type()) $p.name()")
#end
#set ($sb = "$sb)")
$sb
{
    $helper.getRemoteName($intf, $suffix)* thisx = ($helper.getRemoteName($intf, $suffix)*)thisAsVoid;
    /* $helper.getIntfName($intf).$n.name() is a one-way, send-and-forget message so we only do a begin call */
#set ($sb = "$helper.getPointerTypeName($n.type()) _resultobj = $helper.getRemoteName($intf, '')_begin_server_$n.name()(thisx")
#foreach( $p in $n.iterator() )
#set ( $sb = "$sb, $p.name()")
#end
#set ($sb = "$sb);")
    $sb

    return _resultobj;
}

#end
#end
#end
#end
#end
