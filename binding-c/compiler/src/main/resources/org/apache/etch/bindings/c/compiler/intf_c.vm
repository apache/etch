##
## Licensed to the Apache Software Foundation (ASF) under one
## or more contributor license agreements.  See the NOTICE file
## distributed with this work for additional information
## regarding copyright ownership.  The ASF licenses this file
## to you under the Apache License, Version 2.0 (the
## "License"); you may not use this file except in compliance
## with the License.  You may obtain a copy of the License at
##
##   http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing,
## software distributed under the License is distributed on an
## "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
## KIND, either express or implied.  See the License for the
## specific language governing permissions and limitations
## under the License.
##

// This file automatically generated by:
//   $version
//   $now
// This file is automatically created and should not be edited!

\#include "$helper.getIntfFileNameH($intf)"
\#include "etch_url.h"  
\#include "etch_objecttypes.h"
\#include "etch_general.h"
\#include "etch_cache.h"

#foreach( $n in $intf.iterator() )
#if ($n.isConstant())
$helper.getNativeTypeNameForConstants( $n.type() ) $helper.getIntfName( $intf )_$n.name() = $helper.getTypeValue( $n.type(), $n.value() );
#end
#end


## generate CLASSIDs
unsigned short CLASSID_$helper.getIntfName( $intf ).toUpperCase()_SERVICE_INTERFACE;
#foreach( $n in $intf.iterator() )
#if ($n.isStruct() || $n.isEnumx() || $n.isExcept())
#if (!$hasBaseClass)
unsigned short CLASSID_$n.efqname($helper).toUpperCase();
#if ($n.hasExtends())
unsigned short CLASSID_$n.efqname($helper).toUpperCase()_VTABLE;
#end
#end
#end
#end
	
	
int destroy_$helper.getIntfName( $intf )_service_interface (void*);


/*
 * destructors
 */
## generate stucts
#foreach( $n in $intf.iterator() )
#if ($n.isStruct() || $n.isEnumx() || $n.isExcept())
/**
 * destroy_$n.efqname($helper)()
 * $n.name().toString().toLowerCase() object destructor
 */
int destroy_$n.efqname($helper)(void* data)
{
    $n.efqname($helper)* this = ($n.efqname($helper)*)data;
#if($n.isExcept())
	if(!((etch_object*)this)->is_static)
    	etch_object_destroy(this->message);
#end    
#foreach($p in $n.getAllParameters() )
#if($p.type().isArray())
    if(!((etch_object*)this)->is_static && this->$p.name())
        etch_object_destroy(this->$p.name());
#elseif((!$p.type().isBuiltin() && ! $helper.isEnumParam($p)) || $p.type().isString() || $p.type().isObject())
    if(!((etch_object*)this)->is_static && this->$p.name())
        etch_object_destroy(this->$p.name()); 
#end
#end
    destroy_object(this);
    return 0;
}
#end
#end

/* - - - - - - - - - - - - - -  
 * constructors
 * - - - - - - - - - - - - - -  
 */

## generate stucts
#foreach( $n in $intf.iterator() )
#if ($n.isStruct() || $n.isEnumx() || $n.isExcept())
#if (!$hasBaseClass)
/**
 * new_$n.efqname($helper)()
 * $n.name().toString().toLowerCase() object constructor.
 */
$n.efqname($helper)* new_$n.efqname($helper)() 
{
#if($n.hasExtends())
	etchparentinfo* inheritlist = NULL;
    vtabmask* vtab  = NULL;
#end
#if($n.isExcept())

	$n.efqname( $helper)* $n.name().toString().toLowerCase()  = ($n.efqname($helper)*) new_object(sizeof($n.efqname($helper)), 
        ETCHTYPEB_EXCEPTION, get_dynamic_classid_unique(&CLASSID_$n.efqname($helper).toUpperCase()));
    
    $n.name().toString().toLowerCase()->message = new_stringw(L"user generated exception, no default exception message.");
    $n.name().toString().toLowerCase()->errorcode = ETCH_ERROR;
    $n.name().toString().toLowerCase()->excptype = EXCPTYPE_USERDEFINED;
        
#else
    $n.efqname( $helper)* $n.name().toString().toLowerCase() = ($n.efqname($helper)*) new_object(sizeof($n.efqname($helper)), 
        ETCHTYPEB_USER, get_dynamic_classid_unique(&CLASSID_$n.efqname($helper).toUpperCase()));
#end
		
#if($n.hasExtends())
    if (NULL == (vtab = etch_cache_find(get_vtable_cachehkey(get_dynamic_classid_unique(&CLASSID_$n.efqname($helper).toUpperCase()_VTABLE)), 0)))  
    {   
        vtab = new_vtable(NULL, sizeof(vtabmask), get_dynamic_classid_unique(&CLASSID_$n.efqname($helper).toUpperCase()_VTABLE));
        etch_cache_insert(((etch_object*)vtab)->get_hashkey(vtab), vtab, FALSE);
        
        inheritlist = get_vtab_inheritance_list((etch_object*)$n.name().toString().toLowerCase(),
            2, 1, get_dynamic_classid_unique(&CLASSID_$n.efqname($helper).toUpperCase()_VTABLE)); /* create inheritance list */ 
        inheritlist[1].o.obj_type = ETCHTYPEB_USER;
        inheritlist[1].c.class_id = get_dynamic_classid_unique(&CLASSID_$n.getExtends().efqname($helper).toUpperCase()); 
    } 
    ((etch_object*)$n.name().toString().toLowerCase())->vtab = vtab;  
#end
	((etch_object*)$n.name().toString().toLowerCase())->destroy = destroy_$n.efqname($helper);
	((etch_object*)$n.name().toString().toLowerCase())->clone = clone_$n.efqname($helper);

    return $n.name().toString().toLowerCase();
}


#if ($n.isEnumx())
$n.efqname($helper)* new_$n.efqname($helper)_init($n.efqname($helper)_enum val) {
	$n.efqname($helper)* theEnum = new_$n.efqname($helper)();
	theEnum->value = val;
	return theEnum;
}
#end



/**
 * clone_$n.efqname($helper)()
 * $n.name().toString().toLowerCase() object copy constructor.
 */
$n.efqname($helper)* clone_$n.efqname($helper)($n.efqname($helper)* other) 
{
#if($n.hasExtends())
	etchparentinfo* inheritlist = NULL;
    vtabmask* vtab  = NULL;
#end
#if($n.isExcept())
	$n.efqname( $helper)* $n.name().toString().toLowerCase() = ($n.efqname($helper)*) new_object(sizeof($n.efqname($helper)), 
        ETCHTYPEB_EXCEPTION, get_dynamic_classid_unique(&CLASSID_$n.efqname($helper).toUpperCase()));
#else
    $n.efqname( $helper)* $n.name().toString().toLowerCase() = ($n.efqname($helper)*) new_object(sizeof($n.efqname($helper)), 
        ETCHTYPEB_USER, get_dynamic_classid_unique(&CLASSID_$n.efqname($helper).toUpperCase()));
#end
		
#foreach($p in $n.getAllParameters())
    $n.name().toString().toLowerCase()->$p.name() = other->$p.name(); 
#end

#if($n.hasExtends())
    if (NULL == (vtab = etch_cache_find(get_vtable_cachehkey(get_dynamic_classid_unique(&CLASSID_$n.efqname($helper).toUpperCase()_VTABLE)), 0)))  
    {   
        vtab = new_vtable(NULL, sizeof(vtabmask), get_dynamic_classid_unique(&CLASSID_$n.efqname($helper).toUpperCase()_VTABLE));
        etch_cache_insert(((etch_object*)vtab)->get_hashkey(vtab), vtab, FALSE);
        
        inheritlist = get_vtab_inheritance_list((etch_object*)$n.name().toString().toLowerCase(),
            2, 1, get_dynamic_classid_unique(&CLASSID_$n.efqname($helper).toUpperCase()_VTABLE)); /* create inheritance list */ 
        inheritlist[1].o.obj_type = ETCHTYPEB_USER;
        inheritlist[1].c.class_id = get_dynamic_classid_unique(&CLASSID_$n.getExtends().efqname($helper).toUpperCase()); 
    } 
    ((etch_object*)$n.name().toString().toLowerCase())->vtab = vtab;  
#end
	((etch_object*)$n.name().toString().toLowerCase())->destroy = destroy_$n.efqname($helper);
	((etch_object*)$n.name().toString().toLowerCase())->clone = clone_$n.efqname($helper);
	set_etchobj_static_content($n.name().toString().toLowerCase());

    return $n.name().toString().toLowerCase();
}


/**
 * is_$n.efqname( $helper)()
 */
int is_$n.efqname( $helper)(void* x) 
{
    return x && ((etch_object*)x)->class_id == CLASSID_$n.efqname( $helper).toUpperCase();
}

#end
#end
#end

/**
 * new_$helper.getServiceName( $intf )_service_interface
 */
i_$helper.getServiceName( $intf )* new_$helper.getServiceName( $intf )_service_interface ()
{
    i_$helper.getServiceName( $intf )* isvc = (i_$helper.getServiceName( $intf )*) new_object (sizeof(i_$intf.name().name().toLowerCase()), ETCHTYPEB_SVCINTERFACE, 
        get_dynamic_classid_unique(&CLASSID_$helper.getServiceName( $intf ).toUpperCase()_SERVICE_INTERFACE));

    ((etch_object*)isvc)->destroy = destroy_$helper.getServiceName( $intf )_service_interface;

    return isvc;
}

/**
 * destroy_$helper.getServiceName( $intf )_service_interface()
 * i_$helper.getServiceName( $intf ) destructor.
 */
int destroy_$helper.getServiceName($intf)_service_interface (void* data)
{
    i_$helper.getServiceName( $intf )* isvc = (i_$helper.getServiceName( $intf )*)data;
    if (NULL == isvc) return -1;  

    if (!is_etchobj_static_content(isvc))
    {    
    	//nothing to do    
    }
    
    return destroy_objectex((etch_object*)isvc);
}


/* - - - - - - - - - - - - - -  
 * service method stubs
 * - - - - - - - - - - - - - -  
 */

#foreach( $n in $intf.iterator() )
#if ($n.isMessage())
#if (!$n.isHidden())
#set ($sb = "$helper.getPointerTypeName($n.type()) $helper.getServiceName( $intf )_def_$n.name()(void* thisx")
#foreach($p in $n.iterator())
#set ($sb = "$sb, $helper.getTypeName($p.type()) $p.name()")
#end
#set ($sb = "$sb)")
$sb
{
#foreach( $p in $n.iterator())
#if($p.type().isBuiltin())
	etch_object_destroy($p.name());
	$p.name() = NULL;
#else
   etch_object_destroy($p.name());
#end
#end
    return NULL;
}

#end
#end
#end
