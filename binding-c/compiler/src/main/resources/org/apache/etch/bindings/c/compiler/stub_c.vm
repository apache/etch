##
## Licensed to the Apache Software Foundation (ASF) under one
## or more contributor license agreements.  See the NOTICE file
## distributed with this work for additional information
## regarding copyright ownership.  The ASF licenses this file
## to you under the Apache License, Version 2.0 (the
## "License"); you may not use this file except in compliance
## with the License.  You may obtain a copy of the License at
##
##   http://www.apache.org/licenses/LICENSE-2.0
##
## Unless required by applicable law or agreed to in writing,
## software distributed under the License is distributed on an
## "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
## KIND, either express or implied.  See the License for the
## specific language governing permissions and limitations
## under the License.
##

// This file automatically generated by:
//   $version
//   $now
// This file is automatically created and should not be edited!

/*
 * $helper.getStubFileNameI($intf, $suffix) 
 */

\#include "$helper.getBaseFileNameH($intf, $suffix)"
\#include "$helper.getStubFileNameH($intf, $suffix)"
\#include "$helper.getVfFileNameH($intf)"

\#include "etch_url.h"
\#include "etch_objecttypes.h"
\#include "etch_svcobj_masks.h"
\#include "etch_general.h"
\#include "etch_map.h"

#if($helper.isServer($mc))
\#include "etch_exception.h"
\#include "etch_log.h"
\#include "$helper.getIntfFileNameH( $intf )"
#end

#foreach( $n in $intf.iterator() )
#if( $n.isMixin() )
#set( $m = $n.getModule() )
#set( $z = $m.iterator().next() )
\#include "$helper.getStubFileNameH($z, $suffix)"
#end
#end


unsigned short CLASSID_$helper.getStubName($intf, $suffix).toUpperCase();	
	
#if($helper.isServer($mc))
char* $helper.getServiceName($intf).toUpperCase()_$helper.getServiceName($intf).toUpperCase()_ETCHSTBI = "STBI";
#end
	
int destroy_$helper.getStubName($intf, $suffix)(void*);


/* - - - - - - - - - - -
 * stub helper methods 
 * - - - - - - - - - - -
 */

## check if any Message goes to $suffix direction
#if(!$intf.hasMessageDirection($mc) && $helper.hasMessageDirectionBoth($intf))
/**
 * $helper.getStubName($intf, $suffix)_run_nothing_
 */
int $helper.getStubName($intf, $suffix)_run_nothing_ (etch_stub* stub, i_delivery_service* dsvc, 
    void* obj, etch_who* whofrom, etch_message* msg)
{
    i_$helper.getBaseName($intf, $suffix)* client = (i_$helper.getBaseName($intf, $suffix)*)obj;
    $helper.getVfName($intf)_impl* pvfi = NULL;
    $helper.getVfName($intf)* pvf = NULL;
    struct $helper.getBaseName($intf, $suffix)_impl* impl = NULL;

    /* objects specific to service.nothing_() */
    etch_field*  key_foo  = NULL;
    etch_int64*  val_foo  = NULL;
    etch_field*  key_bar  = NULL;
    etch_string* val_bar  = NULL;
    etch_int32* resultobj = NULL;

    etchstub_validate_args (stub, dsvc, msg, client, &pvf, (void**)&pvfi, (void**)&impl);     

    key_foo = NULL;
    key_bar = NULL;
    ETCH_ASSERT(key_foo && key_bar);  

    /* nullarg asserts are initial tests only: server impl   
     * will generate exceptions on nullargs in the real world */
    val_foo = NULL; /* = (etch_int64*)  etch_message_get (msg, key_foo); */
    val_bar = NULL; /* = (etch_string*) etch_message_get (msg, key_bar); */
    ETCH_ASSERT(val_foo && val_bar); 

    /* execute the service method */
    resultobj = NULL; /* server->nothing_ (impl, val_foo, val_bar); */
    ETCH_ASSERT(resultobj); 

    /* transmit reply back to sender */
    return etchstub_send_reply (stub, dsvc, whofrom, msg, (void*) resultobj, TRUE);
}   
#end
#foreach( $n in $intf.iterator() )
#if ($n.isMessage())
#if ($n.isMsgDir($mc) || $n.isMsgDirBoth())
#if (!$n.isHidden())
/**
 * $helper.getStubName($intf, '')_run_$n.name()
 */
int $helper.getStubName($intf, '')_run_$helper.getDirectionName($mc)_$n.name()(etch_stub* stub, i_delivery_service* dsvc, void* obj, etch_who* whofrom, etch_message* msg)
{
    i_$helper.getBaseName($intf, $suffix)* $suffix = (i_$helper.getBaseName($intf, $suffix)*)obj;
    $helper.getServiceName($intf)_$n.name() func;
	int returnCode = 0;
    $helper.getVfName($intf)_impl* pvfi = NULL;
    $helper.getVfName($intf)* pvf = NULL;
    struct $helper.getBaseName($intf, $suffix)_impl* impl = NULL;

    /* objects specific to $helper.getBaseName($intf, $suffix).$name.name()() */
#foreach( $p in $n.iterator() )
    etch_field* key_$p.name() = NULL;
    $helper.getPointerTypeName($p.type()) val_$p.name() = NULL;
#end
#if($n.hasReturn() && !$n.isOneWay())
    $helper.getPointerTypeName($n.getResultMessage().getResultParam().type()) resultobj = NULL;
#end
#if(!$n.hasReturn() && !$n.isOneWay())
    void* resultobj = NULL;
#end
    etchstub_validate_args (stub, dsvc, msg, $suffix, &pvf, (void**)&pvfi, (void**)&impl);

#set($op = '')
#set($sb = '')
#foreach($p in $n.iterator())
#set($sb = "$sb${op}key_$p.name()")
    key_$p.name() = $helper.getVfName($intf)_get_static()->_mf_$helper.getIntfName($intf)_$p.name();
#set($op = ' && ')
#end
#if($sb != '')
    ETCH_ASSERT($sb);
#end

#set($op = '')
#set($sb = '')
#foreach($p in $n.iterator())
##set($sb = "$sb${op}val_$p.name()")
    val_$p.name() = ($helper.getPointerTypeName($p.type())) etch_message_remove(msg, key_$p.name());
##set($op = ' && ')
#end
##if($sb != '')
##    ETCH_ASSERT($sb);
##end
    
    /* execute the service method */
    func = ($helper.getServiceName($intf)_$n.name()) etchmap_findxw(${suffix}->virtuals, $helper.getVfName($intf)_get_static()->str_$helper.getIntfName($intf)_$n.name(), NULL);
    if (func)
#set($sb = '')
#if($n.hasReturn() || $n.hasThrown())
	#set ( $sb = "resultobj = ")
#end
#set ($sb = "$sb func (impl")
#foreach( $p in $n.iterator() )
#set ( $sb = "$sb, val_$p.name()")
#end
#set ($sb = "$sb);")
        $sb
    else
#set($sb = '')
#if($n.hasReturn() || $n.hasThrown())
	#set ( $sb = "resultobj = ")
#end
#set ($sb = "$sb $helper.getServiceName($intf)_def_$n.name() (impl")
#foreach( $p in $n.iterator() )
#set ( $sb = "$sb, val_$p.name()")
#end
#set ($sb = "$sb);")
    $sb

#if(!$n.isOneway() && !$n.hasReturn() && !$n.hasThrown())
    /* transmit reply back to sender */
    returnCode = etchstub_send_reply (stub, dsvc, whofrom, msg, (void*) resultobj, FALSE);
#elseif(!$n.isOneway() && !$n.hasReturn() && $n.hasThrown())
    returnCode = etchstub_send_reply (stub, dsvc, whofrom, msg, (void*) resultobj, resultobj != NULL);
#elseif(!$n.isOneway() && $n.hasReturn() && !$helper.isRefType($n.getResultMessage().getResultParam().type()))
    returnCode = etchstub_send_reply (stub, dsvc, whofrom, msg, (void*) resultobj, TRUE);
#elseif(!$n.isOneway() && $n.hasReturn() && $helper.isRefType($n.getResultMessage().getResultParam().type()))
    returnCode = etchstub_send_reply (stub, dsvc, whofrom, msg, (void*) resultobj, resultobj != NULL);
#elseif($n.isOneway())
    if(resultobj != NULL) {
        returnCode = etchstub_send_reply (stub, dsvc, whofrom, msg, (void*) resultobj, TRUE);
    }
#end
	if(!returnCode){
		etch_object_destroy(msg);
	}
    return returnCode;
}
#end
#end
#end
#end

/* - - - - - - - - - 
 * constructors 
 * - - - - - - - - - 
 */
#if($helper.isServer($mc))

void $helper.getIntfName($intf)_server_set_stub_helpers() {
	/* set stub helper methods */
#foreach( $n in $intf.iterator())
#if ($n.isMessage())
#if ($n.isMsgDir($mc) || $n.isMsgDirBoth())
#if (!$n.isHidden())
    etchtype_set_type_stubhelper($helper.getVfName($intf)_get_static()->_mt_$helper.getServiceName($intf)_$n.name(), $helper.getStubName($intf, '')_run_$helper.getDirectionName($mc)_$n.name());
#end	
#end
#end
#end
#foreach( $n in $intf.iterator() )
#if( $n.isMixin() )
#set( $m = $n.getModule() )
#set( $z = $m.iterator().next() )
	$helper.getIntfName($z)_server_set_stub_helpers();
#end
#end
}
/**
 * new_$helper.getStubName($intf, $suffix)()
 * @param p serv factory parameter bundle, caller retains. 
 *
 * this constructor is called on the server via callback from the listener 
 * socket accept handler <transportfactory>_session_accepted, via the new_server 
 * function pointer to perf_helper.new_helper_accepted_server().
 * java binding passes this constructor the delivery service, however we pass the
 * etch_server_factory parameter bundle, (i_sessionlistener.server_params),
 * i_sessionlistener being the set session interface of etch_tcp_server. 
 */
$helper.getStubName($intf, $suffix)* new_$helper.getStubName($intf, $suffix)(etch_server_factory* p, etch_session* session)
{
    i_delivery_service* ids = session->ds;
    etch_threadpool *qp = p->qpool, *fp = p->fpool;

    $helper.getStubName($intf, $suffix)* mystub = new_serverstub_init (session->server,  
        sizeof($helper.getStubName($intf, $suffix)), destroy_$helper.getStubName($intf, $suffix), ids, qp, fp, p);

    ((etch_object*)mystub)->class_id   = get_dynamic_classid_unique(&CLASSID_$helper.getStubName($intf, $suffix).toUpperCase());
    mystub->session_id = session->session_id;  
	$helper.getIntfName($intf)_server_set_stub_helpers();

    return mystub;
}
#end
#if($helper.isClient($mc))

void $helper.getIntfName($intf)_client_set_stub_helpers() {
	/* set stub helper methods */
#foreach( $n in $intf.iterator())
#if ($n.isMessage())
#if ($n.isMsgDir($mc) || $n.isMsgDirBoth())
#if (!$n.isHidden())
    etchtype_set_type_stubhelper($helper.getVfName($intf)_get_static()->_mt_$helper.getServiceName($intf)_$n.name(), $helper.getStubName($intf, '')_run_$helper.getDirectionName($mc)_$n.name());
#end	
#end
#end
#end
#foreach( $n in $intf.iterator() )
#if( $n.isMixin() )
#set( $m = $n.getModule() )
#set( $z = $m.iterator().next() )
	$helper.getIntfName($z)_client_set_stub_helpers();
#end
#end
}

/**
 * new_$helper.getStubName($intf, $suffix).
 * called from $helper.getRemoteName($intf, $helper.getRemoteDirection($mc))* perfhelper.new_remote_$helper.getRemoteDirection($mc)().
 * @param p client parameter bundle
 */
$helper.getStubName($intf, $suffix)* new_$helper.getStubName($intf, $suffix) (etch_client_factory* p)   
{
    $helper.getStubName($intf, $suffix)* mystub = NULL;
    i_delivery_service* ids = p->dsvc;
    etch_threadpool *qp = p->qpool, *fp = p->fpool;
	
    i_$helper.getBaseName($intf, $suffix)* client = p->iclient;
    ETCH_ASSERT(is_etch_ideliverysvc(ids)); 
    ETCH_ASSERT(is_etch_client_base(client)); 

    mystub = new_clientstub_init (client, sizeof($helper.getStubName($intf, $suffix)), 
        destroy_$helper.getStubName($intf, $suffix), ids, qp, fp, p);

    ((etch_object*)mystub)->class_id  = get_dynamic_classid_unique(&CLASSID_$helper.getStubName($intf, $suffix).toUpperCase());
    mystub->server_id = p->server_id;  

	$helper.getIntfName($intf)_client_set_stub_helpers();
    return mystub;
}
#end

/**
 * is_$helper.getStubName($intf, $suffix)()
 */
int is_$helper.getStubName($intf, $suffix)(void* obj)
{
    return obj && ((etch_object*)obj)->class_id == CLASSID_$helper.getStubName($intf, $suffix).toUpperCase();
}

/**
 * destroy_def_$helper.getStubName($intf, $suffix)()
 * $helper.getStubName($intf, $suffix) user-allocated memory destructor.
 * called back from private object destructor destroy_stub_object().
 * if you explicitly allocate memory in the client stub object, destroy it here.
 */
int destroy_$helper.getStubName($intf, $suffix)(void* data)
{
   /*
     $helper.getStubName($intf, $suffix)* mystub = ($helper.getStubName($intf, $suffix)*)data;
      free custom memory allocations here */
    //etch_free(mystub->my_example_obj); /* free example alloc */

    return 0;
}
