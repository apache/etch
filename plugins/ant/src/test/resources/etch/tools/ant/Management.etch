/* $Id$
 *
 * Copyright 2007-2008 Cisco Systems Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy
 * of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

module cisco.uc.cuae.mgmt

/**
 * Abstraction of functions needed by Management UI.
 */
service Management
{

	include "MediaEngines.txt"
	include "Groups.txt"
	include "TelephonyServer.txt"
	
	///////////
	// USERS //
	///////////
	
	/**
	 * The data of the user.
	 */
	struct UserData
	(
		/** The "globally unique" id of the user */
		string id,
		/** The current name of the user */
		string name,
		/** The current rights of the user */
		string[] rights
	)
	
	/**
	 * Exception thrown when there are problems with users.
	 * @param msg a detail message of the problem.
	 */
	exception UserException( string msg )
	
	/**
	 * Adds a user.
	 * @param name the name of the user.  Name must match pattern (^[\\w\\-]+$)
	 * which includes letters, digits, underscore, and dash.  Name is case
	 * sensitive and must be unique.
	 * @param password the plain text password.
	 * @return the UserData of the added user. Mainly used to communicate
	 * the user's id.
	 * @throws UserException if a user with that name already exists, or
	 * if the name or password is bad.
	 */
	UserData addUser( string name, string password ) throws UserException
	
	/**
	 * Removes the user.
	 * @param id the id ([\\d]+) of the user.
	 * @throws UserException if a user with that id doesn't exist.
	 */
	void removeUser( string id ) throws UserException
	
	/**
	 * Sets the password of the user.
	 * @param id the id ([\\d]+) of the user.
	 * @param password the plain text password.
	 * @throws UserException if a user with that name doesn't exist.
	 */
	void setPassword( string id, string password ) throws UserException
	
	/**
	 * Tests the supplied credentials for correctness.
	 * @param name the name (^[\\w\\-]+$) of the user.
	 * @param password the plain text password.
	 * @return the user data if the name and password match, or null.
	 * @throws UserException if the name is contains bad characters or
	 * there is a database problem.
	 */
	UserData authenticate( string name, string password ) throws UserException
	
	/**
	 * Gets the user data.
	 * @param name the name (^[\\w\\-]+$) of the user.
	 * @return the user data, or null if there is no such user.
	 * @throws UserException if the name contains bad characters or
	 * there is a database problem.
	 */
	UserData getUser( string name ) throws UserException
	
	/**
	 * Gets the user data.
	 * @param id the id ([\\d]+) of the user.
	 * @return the user data, or null if there is no such user.
	 * @throws UserException if the id contains bad characters or
	 * there is a database problem.
	 */
	UserData getUserById( string id ) throws UserException
	
	/**
	 * Gets the number of users matching the pattern.
	 * @param pattern a pattern including wildcard characters (e.g., "a*").
	 * Pass the pattern null or "*" to list all the users.
	 * Must match regex (^[\\w\\-\\*]+$) which includes letters, digits, 
	 * underscore, dash, and the wildcard *.
 	 * @return number of users matching pattern
	 * @throws UserException if the pattern is invalid.
	 */
	int countUsers( string pattern ) throws UserException
	
	/**
	 * Lists the users matching the pattern.
	 * @param pattern a pattern including wildcard characters (e.g., "a*").
	 * Pass the pattern null or "*" to list all the users.
	 * Must match regex (^[\\w\\-\\*]+$) which includes letters, digits, 
	 * underscore, dash, and the wildcard *.
	 * @param offset the offset within the result set of the first item
	 * returned. The first item is at offset 0.
	 * @param length the number of items from the result set to return.
	 * @return array of user data from the result set. If the number of
	 * items returned equals the length parameter, there may be more
	 * available. To retrieve them, call listUsers repeatedly incrementing
	 * offset by length each time until the number of items returned is
	 * less than the length parameter.
	 * @throws UserException if the pattern contains bad characters or
	 * there is a database problem.
	 */
	UserData[] listUsers( string pattern, int offset, int length )
		throws UserException
	
	////////////
	// RIGHTS //
	////////////
	
	/**
	 * The right which grants the user the right to do anything.
	 */
	const string ADMIN_RIGHT = "ADMIN"
	
	/**
	 * Grants the user the specified right.
	 * @param id the id ([\\d]+) of the user.
	 * @param right the name of a right.
	 * @throws UserException if the id contains bad characters, the user is
	 * not found, or if the right is not defined.
	 */
	void grantUserRight( string id, string right ) throws UserException
	
	/**
	 * Tests if the user has a right.
	 * @param id the id ([\\d]+) of the user.
	 * @param right the name of a right.
	 * @return true if the user exists and has the right.
	 * @throws UserException if the id contains bad characters or the user is
	 * not found.
	 */
	boolean hasUserRight( string id, string right ) throws UserException
	
	/**
	 * Denies the user the specified right.
	 * @param id the id ([\\d]+) of the user.
	 * @param right the name of a right.
	 * @throws UserException if the id contains bad characters, the user is
	 * not found, or if the right is not defined.
	 */
	void denyUserRight( string id, string right ) throws UserException
	
	/**
	 * Returns the rights of the user.
	 * @param id the id ([\\d]+) of the user.
	 * @return the rights of the user. Returns an empty array if the user
	 * has no rights.
	 * @throws UserException if the user is not found.
	 */
	string[] listUserRights( string id ) throws UserException
	
	//////////
	// LOGS //
	//////////
	
	/**
	 * A log file name or pattern.
	 */
	struct LogName
	(
		/**
		 * The category of a log file. The category might be null
		 * or empty to specify no category, or a category name
		 * ([a-zA-Z0-9]+) or a pattern ([a-zA-Z0-9*]+).
		 */
		string category,
		/**
		 * The log file name ([a-zA-Z0-9\-.]+) or a pattern ([a-zA-Z0-9\-.*]+).
		 */
		string name
	)
	
	@Extern( java, "java.util.Date", "",
		"etch.bindings.java.util.DateSerializer", "" )
	extern Date
	
	/**
	 * The information of a log file.
	 */
	struct LogFile
	(
		/** The name of the log file */
		LogName name,
		/** The size in bytes */
		int size,
		/** The character encoding (e.g., cp1252 or iso-8859 or ascii, etc.) */
		string encoding,
		/** The last modification date */
		Date modified
	)
	
	/**
	 * The information of an archive file.
	 */
	struct ArchiveFile
	(
		/** The name of the archive file */
		string name,
		/** The size in bytes */
		int size,
		/** last modification date */
		Date modified
	)
	
	/**
	 * Lists the log file categories.
	 * @param pattern might be empty to specify no category, null or "*" to
	 * list all categories, or a category name ([a-zA-Z0-9\-.]+) or a pattern
	 * ([a-zA-Z0-9\-.*]+).
	 * @return an array of category names, or an empty array if there are none.
	 */
	string[] listCategories( string pattern )

	/**
	 * Gets the amount of log files matching the pattern
	 * @param pattern either or both of the LogName fields category or
	 * name may include wildcard specifiers.
	 * @return the log file count
	 */
	int countLogFiles( LogName pattern )
		
	/**
	 * Lists the log files matching the specified LogName pattern. To be
	 * listed, the category of a log file much match pattern.category and
	 * the name of the log file must match pattern.name.
	 * @param pattern either or both of the LogName fields category or
	 * name may include wildcard specifiers.
	 * @param offset the offset within the result set of the first item
	 * returned. The first item is at offset 0.
	 * @param length the number of items from the result set to return.
	 * @return an array of log file info, or an empty array if there are
	 * none that match. If the length of the result equals the length
	 * parameter, then there may be more results available. If the length
	 * of the result is less than length, then there are no more results.
	 */
	LogFile[] listLogFiles( LogName pattern, int offset, int length )
	
	/**
	 * Reads a chunk of a log file.
	 * @param name the name of log file. Neither of the LogName fields
	 * category or name may include wildcard specifiers.
	 * @param offset the offset within the file of the first byte
	 * returned. The first byte is at offset 0.
	 * @param length the number of bytes from the log file to return.
	 * @return data from the log file, or an empty array
	 * if there are no more. If the length of the result equals the length
	 * parameter, then there may be more data available. If the length
	 * of the result is less than the length parameter, then there is no
	 * more data.
	 * @throws LogException if there is a problem reading the log file.
	 */
	byte[] readLogFile( LogName name, int offset, int length )
		throws LogException
	
	/**
	 * Removes log files matching pattern. Both LogName fields category
	 * and name must match in one of the patterns to be removed.
	 * @param patterns either of the LogName fields category or name may
	 * include wildcard specifiers.
	 */
	void removeLogFiles( LogName[] patterns )
	
	//////////////
	// ARCHIVES //
	//////////////
	
	/**
	 * Exception thrown when there is a problem with log files.
	 * @param msg a detail of the problem.
	 */
	exception LogException( string msg )
	
	/**
	 * Archives log files matching pattern. Both LogName fields category
	 * and name must match in one of the patterns to be archived.
	 * @param archiveName the file name of an archive (e.g., foo.zip).
	 * Must match pattern ([a-zA-Z0-9\-.]+).
	 * @param patterns either of the LogName fields category or name may
	 * include wildcard specifiers.
	 * @param replace if true and the named archive already exists it will
	 * be replaced.
	 * @throws LogException if the archive exists and replace is false, or
	 * if the archive name is bad.
	 */
	void archiveLogs( string archiveName, LogName[] patterns, boolean replace )
		throws LogException
	
	/**
	 * Removes the specified archive from the system.
	 * @param archiveName the file name of an archive (e.g., foo.zip).
	 * Must match pattern ([a-zA-Z0-9\-.]+).
	 * @throws LogException if the archive name is bad.
	 */
	void removeArchive( string archiveName ) throws LogException
	
	/**
	 * Lists the available archives.
	 * @return an array of archive file info, or an empty array if
	 * there are none.
	 */
	ArchiveFile[] listArchives()
	
	/**
	 * Reads data from an archive file.
	 * @param archiveName the file name of an archive (e.g., foo.zip).
	 * Must match pattern ([a-zA-Z0-9\-.]+).
	 * @param offset the offset within the file of the first byte
	 * returned. The first byte is at offset 0.
	 * @param length the number of bytes from the archive file to return.
	 * @return data from the archive file, or an empty array
	 * if there are no more. If the length of the result equals the length
	 * parameter, then there may be more data available. If the length
	 * of the result is less than the length parameter, then there is no
	 * more data.
	 * @throws LogException if there is a problem reading the archive file.
	 */
	byte[] readArchive( string archiveName, int offset, int length )
		throws LogException
	
	//////////////////
	// APPLICATIONS //
	//////////////////
	
	/**
	 * Exception related to app errors.
	 * @param msg detail of problem.
	 */
	exception AppException( string msg )
	
	/**
	 * The data of an Application
	 */
	struct Application
	(
		/** The unique id of the application */
		string appId,
		/** The name */
		string name,
		/** The name to display */
		string displayName,
		/** the app version */
		string version,
		/** the current status */
		AppStatus status,
		/** any copyright claim */
		string copyright,
		/** a longer description */
		string description,
		/** the author */
		string author,
		/** the url of the author */
		string authorUrl,
		/** the url for support */
		string supportUrl
	)
	
	/** The current status of the application */
	enum AppStatus
	(
		/** the current state is unknown */
		UNSPECIFIED,
		/** the app is disabled and has been stopped */
		DISABLED_STOPPED,
		/** the app is disabled because of an error while starting */
		DISABLED_ERROR,
		/** not currently used (marked disabled but not yet stopped?) */
		DISABLED_RUNNING,
		/** enabled but not yet running (app server not running?) */
		ENABLED_STOPPED,
		/** enabled and running, all systems are go */
		ENABLED_RUNNING
	)
	
	/**
	 * Begins the process of creating an application install
	 * image. The application install image is not complete
	 * until all the data is written and the file is closed
	 * with commit equal to true.
	 * @param name the final name of the application image file.
	 * @return an id of the application file to use with write
	 * and close.
	 * @throws AppException
	 */
	string createApplicationFile( string name ) throws AppException
	
	/**
	 * Writes some data to the end of the application file.
	 * @param fid the id of the file to be written.
	 * @param data the data to be written.
	 * @throws AppException
	 */
	void writeApplicationFile( string fid, byte[] data ) throws AppException
	
	/**
	 * Closes the application file and either marks it complete
	 * or discards it.
	 * @param fid the id of the file to be closed and marked.
	 * @param commit if true marks the file complete, otherwise
	 * discards it.
	 * @throws AppException
	 */
	void closeApplicationFile( string fid, boolean commit ) throws AppException
	
	/**
	 * Returns the count of applications.
	 * @param pattern restriction pattern on display name, with * and ?
	 * to match any multiple or single characters, respectively.
	 * null means match any (e.g., "*").
	 * @return the count of applications.
	 * @throws AppException
	 */
	int countApplications( string pattern ) throws AppException
	
	/**
	 * Lists the applications. Order by what?
	 * @param pattern restriction pattern on display name, with * and ?
	 * used to match any multiple or single characters, respectively.
	 * null means match any (e.g., "*").
	 * @param offset the offset of the first item to return.
	 * @param count the count of items to return.
	 * @return the info for each application. If the number of items
	 * is < count, then the list is complete. If the number of items
	 * == count, then there might be more items starting at offset + count.
	 * @throws AppException
	 */
	Application[] listApplications( string pattern, int offset, int count )
		throws AppException
	
	/**
	 * Gets info about an application.
	 * @param appId the id of the app.
	 * @throws AppException
	 */
	Application getApplication( string appId ) throws AppException
	
	/**
	 * Enables the application to run. Notifies the cuae server to start it.
	 * @param appId the id of the app.
	 * @throws AppException
	 */
	void enableApplication( string appId ) throws AppException
	
	/**
	 * Disables the application so it will not run. Notifies the cuae server
	 * to stop it.
	 * @param appId the id of the app.
	 * @throws AppException
	 */
	void disableApplication( string appId ) throws AppException
	
	/**
	 * Deletes the application from the system. It must be in the disabled
	 * state.
	 * @param appId the id of the app.
	 * @throws AppException
	 */
	void deleteApplication( string appId ) throws AppException
	
	/////////////
	// SCRIPTS //
	/////////////
	
	/** Information about an application script */
	struct Script
	(
		/** the unique id of the script */
		string scriptId,
		/** the application which owns this script */
		string appId,
		/** the name of this script */
		string name,
		/** the event type which triggers this script */
		string eventType,
		/** this script uses call control services */
		boolean usesCallControl,
		/** this script uses media control services */
		boolean usesMediaControl
	)
	
	/**
	 * Returns the count of scripts of this application.
	 * @param appId the application whose scripts are counted.
	 * @return the count of scripts of this application.
	 * @throws AppException
	 */
	int countScripts( string appId ) throws AppException
	
	/**
	 * Lists the scripts of this application.
	 * @param appId the application whose scripts are listed.
	 * @param offset the offset of the first item to return.
	 * @param count the count of items to return.
	 * @return the info for each script. If the number of items
	 * is < count, then the list is complete. If the number of items
	 * == count, then there might be more items starting at offset + count.
	 * @throws AppException
	 */
	Script[] listScripts( string appId, int offset, int count )
		throws AppException
	
	////////////////
	// PARTITIONS //
	////////////////
	
	struct Partition
	(
		string partitionId,
		string appId,
		string name,
		string description,
		boolean enabled,
		boolean isDefault,
		string preferredCodec,
		string locale,
		boolean useEarlyMedia,
		string callRouteGroupId,
		string mediaResourceGroupId
	)
	
	/**
	 * Counts the partitions of this application.
	 * @param appId the application whose partitions are counted.
	 * @return the count of partitions of this application.
	 * @throws AppException
	 */
	int countPartitions( string appId ) throws AppException
	
	/**
	 * Lists the partitions of this application.
	 * @param appId the application whose partitions are listed.
	 * @param offset the offset of the first item to return.
	 * @param count the count of items to return.
	 * @return the info for each partition. If the number of items
	 * is < count, then the list is complete. If the number of items
	 * == count, then there might be more items starting at offset + count.
	 * @throws AppException
	 */
	Partition[] listPartitions( string appId, int offset, int count )
		throws AppException
	
	/**
	 * Gets the info for the specified partition.
	 * @param partitionId the id of the partition to get.
	 * @return the info for the partition.
	 * @throws AppException
	 */
	Partition getPartition( string partitionId ) throws AppException
	
	/**
	 * Adds a new partition to an application.
	 * @param partition the info for the new partition.
	 * @return the updated info for the new partition.
	 * @throws AppException
	 */
	Partition addPartition( Partition partition ) throws AppException
	
	/**
	 * Updates an existing partition of an application.
	 * @param partition the info to update for the partition.
	 * @throws AppException
	 */
	void updatePartition( Partition partition ) throws AppException
	
	/**
	 * Deletes an existing partition.
	 * @param partitionId the id of the partition to delete.
	 * @throws AppException if the partition does not exist or is the
	 * default partition for the application.
	 */
	void deletePartition( string partitionId ) throws AppException
	
	///////////////////
	// CONFIGURATION //
	///////////////////
	
	@Extern( java, "cisco.uc.cuae.mgmt.util.StrArray", "",
		"cisco.uc.cuae.mgmt.util.StrArraySerializer", "" )
	extern StrArray
	
	@Extern( java, "cisco.uc.cuae.mgmt.util.StrTable", "",
		"cisco.uc.cuae.mgmt.util.StrTableSerializer", "" )
	extern StrTable
	
	@Extern( java, "etch.bindings.java.util.StrStrHashMap", "",
		"etch.bindings.java.util.StrStrHashMapSerializer", "" )
	extern StrStrMap
	
	/**
	 * Enumeration which describes the possible configuration value types.
	 */
	enum BaseConfigType
	(
		/** value is of unknown type */
		UNSPECIFIED,
		/** value is true or false */
		BOOLEAN,
		/** value is an integral or floating point number */
		NUMBER,
		/** value is a string */
		STRING,
		/** value is a string which is obscured by the ui */
		PASSWORD,
		/** value is a date/time (java.util.Date) */
		DATETIME,
		/** value is a string that is an ip address (e.g., 192.168.1.19) or a resolvable hostname */
		IP_ADDRESS,
		/** value is a one dimensional array of string (StrArray) */
		ARRAY,
		/** value is a map of string->string (StrStrHashMap) */
		MAP,
		/** value is a two dimensional array of string (StrTable) */
		TABLE,
		/** value is a string from a list of values (see ConfigType.values) */
		ENUM
	)
	
	/**
	 * Type of a configuration variable.
	 */
	struct ConfigType
	(
		/** The basic value type. */
		BaseConfigType type,
		/** For ENUM types: the set of possible values */
		string[] values,
		/** For NUMBER types: the minimum allowed value. */
		int minValue,
		/** For NUMBER types: the maximum allowed value. */
		int maxValue
	)
	
	/**
	 * A configuration value of a partition.
	 */
	struct Configuration
	(
		/** The id of this configuration */
		string configId,
		/** The owning partition id */
		string partitionId,
		/** The owning application id */
		string appId,
		/** The name (like a key name) */
		string name,
		/** The display name */
		string displayName,
		/** The description */
		string description,
		/** The type */
		ConfigType type,
		/** The value is read-only and cannot be set. */
		boolean readOnly,
		/** The value is required and cannot be null or blank. */
		boolean required,
		/** The value is hidden from the user */
		boolean hidden,
		/** The value (as specified by type) */
		object value
	)
	
	/**
	 * Counts the number of configurations in a partition. The count is the
	 * same for any partition of an application (always the number of
	 * configurations in the default partition).
	 * @param partitionId the owning partition.
	 * @return the count of configurations in this partition.
	 * @throws AppException
	 */
	int countConfigurations( string partitionId ) throws AppException
	
	/**
	 * Lists the configurations in a partition. The list will include
	 * the specific configurations of this partition with any missing
	 * configurations filled in from the default partition.
	 * @param partitionId the owning partition.
	 * @param offset the offset in the list of the first item to return.
	 * @param count the number of items to return.
	 * @throws AppException
	 */
	Configuration[] listConfigurations( string partitionId, int offset,
		int count ) throws AppException
	
	/**
	 * Updates the configations in the specified partition.
	 * @param configs the configurations to update. Only the value is updated.
	 * Each config must be a valid configuration as returned by
	 * listConfigurations. If inPartitionId == configs[k].partitionId, then
	 * the value of the configuration identified by configs[k].configId is
	 * updated. If inPartitionId != configs[k].partitionId, then a copy of
	 * the configuration identified by configs[k].configId is created in
	 * inPartitionId with the specified value.
	 * @param inPartitionId the target configuration to be updated.
	 * @return the updated configurations.
	 * @throws AppException
	 */
	Configuration[] updateConfiguration( Configuration[] configs,
		string inPartitionId ) throws AppException
	
	/**
	 * Deletes the configuration (if it isn't in the default partition).
	 * @param configId the id of the configuration to delete.
	 * @throws AppException if the configuration is in the default
	 * partition.
	 */
	void deleteConfiguration( string configId ) throws AppException
	
	//////////////
	// TRIGGERS //
	//////////////
	
	/** Information on a script trigger. */
	struct Trigger
	(
		/** the unique id of this trigger */
		string triggerId,
		/** the name */
		string name,
		
		/** the id of the script to run */
		string scriptId,
		/** DERIVED: the name of the script to run */
		string scriptName,
		/** DERIVED: the triggering event type */
		string eventType,

		/** the id of the partition used to init the script instance */
		string partitionId,
		/** DERIVED: name of the partition used to init the script instance */
		string partitionName,
		
		// note that both script and partition must come from the same app.
		
		/** DERIVED: the id of the owning app */
		string appId,
		/** DERIVED: the name of the owning app */
		string appName
	)

	/** A name / value pair associated with a trigger */
	struct TriggerParam
	(
		/** a trigger event parameter name */
		string name,
		/** a trigger event parameter value (not null) */
		string value
	)

	/**
	 * Returns the set of event parameter names for a trigger.
	 * NOTE: Possibly not implemented or implementable.
	 * @param eventType a trigger event type (e.g., "blah???").
	 * @return the set of event parameter names for a trigger, null
	 * if unknown (in that case, programmer can enter whatever they
	 * want).
	 */
	string[] getTriggerParams( string eventType ) throws AppException

	/**
	 * Counts the number of triggers.
	 * @return the number of triggers.
	 */
	int countTriggers() throws AppException
	
	/**
	 * Lists the triggers (order by name???).
	 * @param offset the offset of the first item to return.
	 * @param count the count of items to return.
	 * @return the info for each trigger. If the number of items
	 * is < count, then the list is complete. If the number of items
	 * == count, then there might be more items starting at offset + count.
	 * @throws AppException
	 */
	Trigger[] listTriggers( int offset, int count ) throws AppException
	
	/**
	 * Gets the info for the specified trigger.
	 * @param triggerId the unique id of the trigger.
	 * @return the info of the trigger or null.
	 * @throws AppException
	 */
	Trigger getTrigger( string triggerId ) throws AppException

	/**
	 * Adds the trigger from the supplied info.
	 * @param trigger the info for the new trigger. Only the name,
	 * scriptId and partitionId need be set. The other fields are ignored.
	 * Remember that script and partition must have the same app.
	 * @return the updated trigger info, with all fields set.
	 * @throws AppException
	 */
	Trigger addTrigger( Trigger trigger ) throws AppException
	
	/**
	 * Updates the trigger info. What fields are updated??? scriptId and
	 * partitionId???
	 * @param trigger the new trigger info.
	 * @throws AppException
	 */
	void updateTrigger( Trigger trigger ) throws AppException
	
	/**
	 * Deletes the specified trigger.
	 * @param triggerId the unique id of the trigger.
	 * @throws AppException
	 */
	void deleteTrigger( string triggerId ) throws AppException
	
	/**
	 * Gets the event parameter values. Each unique name which appears
	 * in the param list represents a constraint which MUST be satisfied
	 * in order for an event to trigger the script. Where a given name
	 * appears multiple times with different values, it may have any one
	 * of the values specified.
	 * @param triggerId the unique id of the trigger.
	 * @return the trigger params ordered by name.
	 * @throws AppException
	 */
	TriggerParam[] getParams( string triggerId ) throws AppException

	/**
	 * Sets the trigger parameters. The current list is dumped and this
	 * list replaces it (performed as an atomic transaction).
	 * @param triggerId the unique id of the trigger.
	 * @param triggers the list of name / value pairs in any order. The values
	 * may not be null.
	 * @throws AppException
	 */
	void setParams( string triggerId, TriggerParam[] triggers )
		throws AppException


	//////////////
	// LICENSE  //
	//////////////
	
	/**
	 * Exception related to app errors.
	 * @param msg detail of problem.
	 */
	exception LicException( string msg )
	
	/* Struct for License Info */
	struct LicData
	(
		string expiration,
		string amountlic,
		string scriptversion,
		string scriptexpiration,
		string incType
	)
	
	/* Struct for License Info */
	struct LicInfo
	(
		string hostname,
		string macaddress,
		string feature,
		string version,
		string expiration,
		LicData[] licInfo				
	)
	
	/**
	 * Verify the License file.
	 * @param licensefilename the filename of file to be verified.
	 * @throws LicException if file error
	 */
	boolean verifyLicenseFile( string licensefilename ) throws LicException
		
	/**
	 * Begins the process of creating an license install
	 * image.
	 * @return an id of the application file to use with write
	 * and close.
	 * @throws LicException
	 */
	string createLicenseFile( string name ) throws LicException
	
	/**
	 * Writes some data to the end of the license file.
	 * @param fid the id of the file to be written.
	 * @param data the data to be written.
	 * @throws LicException
	 */
	void writeLicesenFile( string fid, byte[] data ) throws LicException
	
	/**
	 * Closes the license file and either marks it complete
	 * or discards it.
	 * @param fid the id of the file to be closed and marked.
	 * @param commit if true marks the file complete, otherwise
	 * discards it.
	 * @throws LicException
	 */
	void closeLicenseFile( string fid, boolean commit ) throws LicException

	/**
	 * UnInstall the License file.
	 * @param licensefilename the filename of file to be uninstalled.
	 * @throws LicException if file error
	 */
	void unInstallLicenseFile( string licensefilename ) throws LicException
	
	/**
	 * Get License File Info
	 * @param licensefilename the filename of file get info from.
	 * @throws LicException if file error
	 */
	LicInfo getLicInfo( string licensefilename ) throws LicException
	
	/** struct representing a licensed items */
	struct LicenseId
	(
		/** an identifier to use with getActiveLicense */
		string oid,
		/** an identifier to use with getLicensed */
		string lictype,
		/** an identifier to use with getLicenseMax */
		string maxlictype,
		/** the name to use to display the licensed item */
		string displayName
	)
	
	/**
	 * @return the list of valid licensed items
	 */
	LicenseId[] getLicenseIds()
	
	/**
	 * Get Loaded Licenses
	 * @throws LicException if file error
	 */
	string[] getLoadedLicenses() throws LicException	
	
	/**
	 * Get Active License Count
	 * @param oid the license type.
	 * @throws LicException if file error
	 */
	int getActiveLicense(string oid) throws LicException	
	
	/**
	 * Get License Max Count
	 * @param lictype the license type.
	 * @throws LicException if file error
	 */
	int getLicenseMax(string lictype) throws LicException

	/**
	 * Get Licensed Count
	 * @param lictype the license type.
	 * @throws LicException if file error
	 */
	int getLicensed(string lictype) throws LicException
		
	/**
	 * Get CUAE Licensed Mode
	 * @throws LicException if file error
	 */
	string getCUAELicenseMode() throws LicException
	
	/**
	 * Get CUME Lice Mode
	 * @throws LicException if file error
	 */
	string getCUMELicenseMode() throws LicException	


	///////////
	// TRACE //
	///////////
	
	/**
	 * The config entries of the LogServer and Logger components.
	 */
	struct LogServerAndLoggerConfigData
	(
		/** The dbId of the MaxFileLogLines config entry */
		string maxFileLogLinesConfigId,
		/** The value of the MaxFileLogLines config entry */
		int maxFileLogLines,
		/** The dbId of the MaxFiles config entry */
		string maxFilesConfigId,
		/** The value of the MaxFiles config entry */
		int maxFiles,
		/** The dbId of the LoggerPort config entry */
		string loggerPortConfigId,
		/** The value of the LoggerPort config entry */
		int loggerPort,
		/** The dbId of the LogServerSinkLoggerLevel config entry */
		string logServerSinkLoggerLevelConfigId,
		/** The value of the LogServerSinkLoggerLevel config entry */
		string logServerSinkLoggerLevel,
		/** The dbId of the EnableLoggerQueueDiag config entry */
		string enableLoggerQueueDiagConfigId,
		/** The value of the EnableLoggerQueueDiag config entry */
		boolean enableLoggerQueueDiag
	)
	
	/** The LogLevel config entry of each CUAE component */
	struct ComponentTraceLevelConfigData
	(
		/** The dbId of the LogLevel config entry */
		string configEntryId,
		/** The display name of the component that the config entry belongs to */
		string componentDisplayName,
		/** The type display name of the corresponding component */
		string componentTypeDisplay,
		/** The value of the LogLevel config entry */
		string traceLevel
	)
		
	/**
	 * Exception thrown when there are problems with reading or updating trace
	 * config data.
	 * @param msg a detail message of the problem.
	 */
	exception TraceException( string msg )
	
	/**
	 * Reads LogServer and Logger config data from database.
	 *
	 * @return The config data currently saved in database
	 * @throws TraceException if any failure with DB read
	 */
	LogServerAndLoggerConfigData getLogServerAndLoggerConfigData( ) throws TraceException
	
	/**
	 * Saves LogServer and Logger config data to database.
	 *
	 * @param newData The config data to be saved in database
	 * @throws TraceException if any failure with value validation or DB write
	 */
	void updateLogServerAndLoggerConfigData( LogServerAndLoggerConfigData newData ) throws TraceException

	/**
	 * Retrieves LogLevel config data from database for all CUAE components.
	 *
	 * @return The LogLevel config data currently saved in database
	 * @throws TraceException if any failure with DB read
	 */	
	ComponentTraceLevelConfigData[] getComponentTraceLevelConfigData() throws TraceException

	/**
	 * Batch updates selected LogLevel config entry values.
	 *
	 * @param traceLevelConfigEntryIds The selected TraceLevel config entry dbIds
	 * @param traceLevel The TraceLevel config value for update
	 * @throws TraceException if any failure with DB write
	 */		
	void updateTraceLevelConfigValues( string[] traceLevelConfigEntryIds, string traceLevel) throws TraceException

	/**
	 * Update single LogLevel config entry value
	 *
	 * @param traceLevelConfigEntryId The config entry dbId to be updated
	 * @param traceLevel The TraceLevel config value for update
	 * @throws TraceException if any failure with DB write
	 */
	void updateTraceLevelConfigValue( string traceLevelConfigEntryId, string traceLevel) throws TraceException
	
	/**
	 * Retrieves dbId of the LogLevel config entry of a given component name.
	 *
	 * @param componentName The component name
	 * @return The LogLevel config entry dbId of the given component
	 * @throws TraceException if any failure with DB read
	 */
	string getTraceLevelConfigEntryId( string componentName ) throws TraceException
	
	/**
	 * Retrieves the value of the LogServer's MaxFileLogLines config entry
	 *
	 * @return The value of the LogServer's MaxFileLogLines config entry
	 * @throws TraceException if any failure with DB read
	 */
	int getMaxFileLogLines( ) throws TraceException

	/**
	 * Updates the value of the LogServer's MaxFileLogLines config entry
	 *
	 * @param maxFileLogLines The value of the LogServer's MaxFileLogLines config entry
	 * @throws TraceException if any failure with value validation or DB write
	 */	
	void updateMaxFileLogLines( int maxFileLogLines ) throws TraceException
	
	/**
	 * Retrieves the value of the LogServer's MaxFiles config entry
	 *
	 * @return The value of the LogServer's MaxFiles config entry
	 * @throws TraceException if any failure with DB read
	 */
	int getMaxFiles( ) throws TraceException

	/**
	 * Updates the value of the LogServer's MaxFiles config entry
	 *
	 * @param maxFiles The value of the LogServer's MaxFiles config entry
	 * @throws TraceException if any failure with value validation or DB write
	 */		
	void updateMaxFiles( int maxFiles ) throws TraceException
	
	/**
	 * Retrieves the value of the Logger's LoggerPort config entry
	 *
	 * @return The value of the Logger's LoggerPort config entry
	 * @throws TraceException if any failure with DB read
	 */
	int getLoggerPort( ) throws TraceException
	
	/**
	 * Updates the value of the Logger's LoggerPort config entry
	 *
	 * @param loggerPort The value of the Logger's LoggerPort config entry
	 * @throws TraceException if any failure with value validation or DB write
	 */
	void updateLoggerPort( int loggerPort) throws TraceException
	
	/**
	 * Retrieves the value of the Logger's LogServerSinkLoggerLevel config entry
	 *
	 * @return The value of the Logger's LogServerSinkLoggerLevel config entry
	 * @throws TraceException if any failure with DB read
	 */	
	string getLogServerSinkLoggerLevel( ) throws TraceException
	
	/**
	 * Updates the value of the Logger's LogServerSinkLoggerLevel config entry
	 *
	 * @param logServerSinkLoggerLevel The value of the Logger's LogServerSinkLoggerLevel config entry
	 * @throws TraceException if any failure with value validation or DB write
	 */		
	void updateLogServerSinkLoggerLevel( string logServerSinkLoggerLevel ) throws TraceException

	/**
	 * Retrieves the value of the Logger's EnableLoggerQueueDiag config entry
	 *
	 * @return The value of the Logger's EnableLoggerQueueDiag config entry
	 * @throws TraceException if any failure with DB read
	 */		
	boolean getEnableLoggerQueueDiag( ) throws TraceException

	/**
	 * Updates the value of the Logger's EnableLoggerQueueDiag config entry
	 *
	 * @param enableLoggerQueueDiag The value of the Logger's EnableLoggerQueueDiag config entry
	 * @throws TraceException if any failure with value validation or DB write
	 */	
	void updateEnableLoggerQueueDiag( boolean enableLoggerQueueDiag ) throws TraceException
	
	//////////////
	// ALARMS////
	/////////////
	
			
	/**
	 * Thrown when a call to the AlarmManager API throws an exception.
	 * @param msg Details of the exception
	 */
	exception AlarmException( string msg )
	
	/**
	 * Thrown when a call to the EventLog API throws an exception.
	 * @param msg Details of the exception
	 */
	exception EventLogException( string msg )
		
	
	/** 
	 * Enumeration for the Alarm Severity 
	 */
	enum EventLogSeverity 
	( 
		UNSPECIFIED, 
		ERROR, 
		WARNING, 
		OK
	)
	
	/** 
	 * Enumeration for the Alarm Status 
	 */
	enum EventLogStatus 
	( 
		UNSPECIFIED, 
		OPEN, 
		ACKNOWLEDGED, 
		RESOLVED
	)
	
	/** 
	 * Enumeration for the Alarm Status 
	 */
	enum EventLogType
	( 
		ALARM,
		EVENT
	)
	
	/** 
	 * Enumeration for AlarmCOMPManagerType
	 */
	
	enum AlarmCompManagerType 
	( 
		SMTP, 
		SNMP		
	)
	
	
	/** 
	 * Enumeration for AlarmTriggerLevel
	 */
	enum AlarmTriggerLevel
	( 
		Yellow, 
		Red, 
		Both
	)
	
	
	/** 
	 * Data describing an alarm
	 */
	
	struct EventLogData (
		
		Date timeOccurred,
		Date timeRecovered,
		string alarmId,
		int oid,
		string msg,
		string msgDetails,
		string alarmSourceName,
		string alarmmSourceIpAddress,
		EventLogSeverity sev,
		EventLogStatus status,
		string eventType
		
	)
	
	/** 
	 * Data describing an Alarm Component Manager (SMTP, SNMP etc)
	 */
	struct AlarmCompManager (
		string alarmCompManagerId,
	 	AlarmCompManagerType type,
	 	string recipient,
	 	string sender,
	 	string server,
	 	string name,
	 	string password,
	 	int port,
	 	AlarmTriggerLevel triggerLevel,
	 	boolean isSecure
	)
	
	/** 
	 * Data describing an OID
	 */
	struct OIDData (
	string oidId,
	string oidType,
	string description,
	boolean isIgnore
	)
	
	
	
	/**
	 * Retrieves the Active Alarms from the DB
	 * @param status Indicates the status of alarm the user wants to retrieve (for eg. open, resolved)
	 * @param offset the offset of the first item to return.
	 * @param count Number of items to return
	 * @return An array of the Alarm Data
	 * @throws EventLogException if any failure with DB read
	 */		
	
	EventLogData[] getAlarmList(EventLogStatus status, int offset, int count) throws EventLogException
	
	
	
	/**
	 * Retrieves the count of Alarms from the DB
	 * @param status Indicates the status of alarm the user wants to retrieve (for eg. open, resolved)
	 * @return Number of Alarms
	 * @throws EventLogException if any failure with DB read
	 */		
	 	 
	 int countAlarmList(EventLogStatus status)	throws EventLogException
	
	
	
	/**
	 * Retrieves the Event Log Entries from the DB
	 * @param offset the offset of the first item to return.
	 * @param count Number of items to return
	 * @return An array of the Event Log Data
	 * @throws EventLogException if any failure with DB read
	 */	
	 	
	EventLogData[] getEventLogList(int offset, int count) throws EventLogException
	
	/**
	 * Retrieves the count of Event Log from the DB
	 * 
	 * @return Number of Alarms
	 * @throws EventLogException if any failure with DB read
	 */		
	 	 
	 int countEventLogList() throws EventLogException	
	
	
	
	/**
	 * Allows user to dowload MIB file from Server
	 * @param offset the offset within the result set of the first item
	 * returned. The first item is at offset 0.
	 * @param length the number of items from the result set to return.
	 * @return Byte Array containing the data in file
	 * @throws AlarmException if any problem in reading file
	 */		
	
	byte[] readMIBFile(int offset, int length) throws AlarmException
	
	/**
	 * Allows user to get MIB file Size from Server
	 * 
	 * @return String which contains file size
	 * @throws AlarmException if any problem in getting the file size
	 */		
	
	string readMIBFileSize() throws AlarmException
	
	/**
	 *  Allows user to create AlarmComponentManager (eg SMTP, SNMP)
	 *
	 * @param alarmCompManager Data for creating the AlarmComponentManager
	 * @return Created AlarmCompManager
	 * @throws AlarmException if any failure in creating AlarmCompManager 
	 */		
	
	AlarmCompManager createAlarmCompManager(AlarmCompManager alarmCompManager) throws AlarmException
	
	/**
	 * Allows user to ignore or not ignore alarm
	 * @param ignore The boolean value indicating whether alarm should be ignored or not
	 * @param oids An array of OID
	 * @throws AlarmException if any failure in modifying the alarm
	 */		
	
	void updateIgnoreAlarm(boolean ignore,int[] oids) throws AlarmException
	
	/**
	 * Allows user to change attributes of single or multiple alarams
	 * @param status An enum value indicating the status of the alarm
	 * @param alarmId An array of AlarmData id
	 * @throws AlarmException if any failure in modifying the alarm
	 */		
	
	void updateAlarmData(EventLogStatus status,string[] alarmId) throws AlarmException
	
	
	/**
	 * Allows user to get OID List
	 *
	 * @return An array containg the OID Data. 
	 * @throws AlarmException if any failure in getting the OID List
	 */		
	
	OIDData[] getOIDList() throws AlarmException
	
	
	
	/**
	 * Allows user to get AlarmComponentManager
	 *
	 * @param type Type indicating the kind of AlarmComponentManager to retrieve
	 * @return An array containg the AlarmCompManager Data. For now the array will contain one value
	 * @throws AlarmException if any failure in modifying the alarm
	 */		
	
	AlarmCompManager[] getAlarmComponentManagerList(AlarmCompManagerType type) throws AlarmException
	
	/**
	 * Allows user to delete AlarmComponentManager
	 *
	 * @param type Type of the alarmCompManager to delete
	 * @throws AlarmException if any failure in modifying the alarm
	 */		
	
	void deleteAlarmComponentManager(AlarmCompManagerType type) throws AlarmException
	
	
	
	
	
	//////////////
	// SERVICES //
	//////////////
	
    /**
     * Structure that describes a Service and its current status.
     */
	struct Service
	(
		/** The unique identifier for the service. */
		string serviceId,
		
		/** The service name. */
		string name,
		
		/** A more descriptive service name. */
		string displayName,
		
		/** <code>true</code> if the service is enabled; otherwise, <code>false</code>. */
		boolean enabled,
		
		/** <code>true</code> if the service was stopped by the user; otherwise <code>false</code>. */
		boolean userStopped,
		
		/** The description of the service. */
		string description,
		
		/** 
		 * The state of the service. 
		 * @see ServiceState
		 */
		ServiceState state
	)
		
	/** 
	 * Enumeration for the service state. 
	 */
	enum ServiceState 
	( 
		CONTINUE_PENDING, 
		PAUSE_PENDING, 
		PAUSED, RUNNING, 
		START_PENDING, 
		STOP_PENDING, 
		STOPPED,
		UNKNOWN
	)
	
	/**
	 * Thrown when a call to the Service API throws an exception.
	 */
	exception ServiceException( string msg )
	
	/**
	 * @return The total number of service available.
	 * @throws ServiceException
	 */
	int countServices() throws ServiceException
	
	/**
     * Retrieves a paginated list of at most the given number of services, 
     * starting with the given offset.
     * 
     * @param offset 
     *                The offset in the result set from which to start the 
     *                collection.
     * @param count 
     *                The maximum number of records to return.
	 * @throws ServiceException
     * @return An array of Service structures.
     */
    Service[] listServices( int offset, int count ) throws ServiceException
	
	/**
	 * Requests a Service structure for the service with the given ID.
	 * 
	 * @param serviceId 
	 *                The identifier for the requested service.
	 * @return The requested Service structure.
	 * @throws ServiceException
	 */
	Service getService( string serviceId ) throws ServiceException
	
	/** 
	 * Starts the described service.
	 *
	 * @param serviceId 
	 *                The identifier for the requested service.
	 * @throws ServiceException
	 */
	void startService( string serviceId ) throws ServiceException
	
	/** 
	 * Stops the described service. 
	 *
	 * @param serviceId 
	 *                The identifier for the requested service.
	 * @throws ServiceException
	 */
	void stopService( string serviceId ) throws ServiceException
	
	/** 
	 * Restarts the described service. 
	 *
	 * @param serviceId 
	 *                The identifier for the requested service.
	 * @throws ServiceException
	 */
	void restartService( string serviceId ) throws ServiceException
	
	/** 
	 * Terminates the described service. 
	 *
	 * @param serviceId 
	 *                The identifier for the requested service.
	 * @throws ServiceException
	 */
	void killService( string serviceId ) throws ServiceException
	
	/** 
	 * Enables the described service. 
	 *
	 * @param serviceId 
	 *                The identifier for the requested service.
	 * @throws ServiceException
	 */
	void enableService( string serviceId ) throws ServiceException
	
	/** 
	 * Disables the described service. 
	 *
	 * @param serviceId 
	 *                The identifier for the requested service.
	 * @throws ServiceException
	 */
	void disableService( string serviceId ) throws ServiceException
	
	////////////////
	// STATISTICS //
	////////////////
	
	/**
	 * Thrown when a call to the Statistics API throws an exception.
	 */
	exception StatException( string msg )
	
	/** Represents a statistical item */
	struct StatItem
	(
	    /** The ID of the stat item. */
	    string statItemId,
		/** An identifier to use with that statistics server. */
		string oid,
		/** The name of the stat item. */
		string name,
		/** The name to use to display the stat item. */
		string displayName,
		/** The description of the stat item.*/
		string description
	)
	
	/** 
	 * Enumeration for the interval to measure. 
	 */
	enum StatInterval 
	( 
		STATS_INTERVAL_HOUR, 
		STATS_INTERVAL_6HOURS, 
		STATS_INTERVAL_12HOURS, 
		STATS_INTERVAL_DAY, 
		STATS_INTERVAL_WEEK, 
		STATS_INTERVAL_MONTH,
		STATS_INTERVAL_YEAR
	)
	
	/**
     * Retrieves a of stat items. 
     * 
	 * @throws StatException
     * @return An array of StatItem structures.
     */
    StatItem[] listStatItems() throws StatException
	
	/**
	 * Requests a StatItem structure for the stat item with the given ID.
	 * 
	 * @param statItemId 
	 *                The identifier for the requested stat item.
	 * @return The requested StatItem structure.
	 * @throws StatException
	 */
	StatItem getStatItem( string statItemId ) throws StatException
	
	/**
	 * Requests a StatItem structure for the stat item with the given ID.
	 * 
	 * @param oid 
	 *                The oid identifier for the requested stat item.
	 * @return The requested StatItem structure.
	 * @throws StatException
	 */
	StatItem getStatItemByOID( string oid ) throws StatException
	
	/**
	 * Get count of active items.
	 *
	 * @param oid
	 *                the stat type.
	 * @throws StatException 
	 *                if error fetching statistic.
	 */
	int getActiveStat(string oid) throws StatException
	
	/**
	 * Get count of active items for each item in the array.
	 *
	 * @param oids
	 *                an array of stat types.
	 * @throws StatException 
	 *                if error fetching statistics.
	 */
	int[] getActiveStats(string[] oids) throws StatException
	
	/**
	 * Generates a statistical plot.
	 * 
	 * @param oid
	 *                an id for the stat server.
	 * @param interval
	 *                the interval for which to plot.
	 * @return 
	 *                a fid for the plot file.
	 * @throws StatException 
	 *                if error fetching statistics.
	 */
	string createStatPlot(string oid, StatInterval interval) throws StatException
	
	/**
	 * Reads a statistical plot.
	 * 
	 * @param fid 
	 *                the plot's file identifier.
	 * @param count 
	 *                the number of bytes from the image file to return.
	 * @return 
	 *                data from the plot's image file, or an empty array
	 *                if there are no more. If the length of the result equals 
	 *                the count parameter, then there may be more data 
	 *                available. If the length of the result is less than the 
	 *                count parameter, then there is no more data.
	 * @throws StatException 
	 *                if error fetching statistics.
	 */
	byte[] readStatPlot( string fid, int count ) throws StatException
	
	/**
	 * Closes a statistical plot and deletes it.
	 * 
	 * @param fid 
	 *                the plot's file identifier.
	 * @throws StatException 
	 *                if error fetching statistics.
	 */
	void closeStatPlot( string fid ) throws StatException
}